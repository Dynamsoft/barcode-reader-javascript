/**
* Dynamsoft JavaScript Library
* @product Dynamsoft Barcode Reader JS Edition
* @website http://www.dynamsoft.com
* @preserve Copyright 2021, Dynamsoft Corporation
* @author Dynamsoft
* @version 8.6.1 (js 20210628)
* @fileoverview Dynamsoft JavaScript Library for Barcode Reader
* More info on DBR JS: https://www.dynamsoft.com/Products/barcode-recognition-javascript.aspx
*/
// Generated by dts-bundle-generator v4.3.0

/// <reference types="node" />

interface LocalizationResult {
	/**
	 * The angle of a barcode. Values range from 0 to 360.
	 */
	angle: number;
	/**
	 * The X coordinate of the left-most point.
	 */
	x1: number;
	/**
	 * The X coordinate of the second point in a clockwise direction.
	 */
	x2: number;
	/**
	 * The X coordinate of the third point in a clockwise direction.
	 */
	x3: number;
	/**
	 * The X coordinate of the fourth point in a clockwise direction.
	 */
	x4: number;
	/**
	 * The Y coordinate of the left-most point.
	 */
	y1: number;
	/**
	 * The Y coordinate of the second point in a clockwise direction.
	 */
	y2: number;
	/**
	 * The Y coordinate of the third point in a clockwise direction.
	 */
	y3: number;
	/**
	 * The Y coordinate of the fourth point in a clockwise direction.
	 */
	y4: number;
}
declare enum EnumBarcodeFormat {
	BF_ALL = -31457281,
	BF_ONED = 1050623,
	BF_GS1_DATABAR = 260096,
	BF_CODE_39 = 1,
	BF_CODE_128 = 2,
	BF_CODE_93 = 4,
	BF_CODABAR = 8,
	BF_ITF = 16,
	BF_EAN_13 = 32,
	BF_EAN_8 = 64,
	BF_UPC_A = 128,
	BF_UPC_E = 256,
	BF_INDUSTRIAL_25 = 512,
	BF_CODE_39_EXTENDED = 1024,
	BF_GS1_DATABAR_OMNIDIRECTIONAL = 2048,
	BF_GS1_DATABAR_TRUNCATED = 4096,
	BF_GS1_DATABAR_STACKED = 8192,
	BF_GS1_DATABAR_STACKED_OMNIDIRECTIONAL = 16384,
	BF_GS1_DATABAR_EXPANDED = 32768,
	BF_GS1_DATABAR_EXPANDED_STACKED = 65536,
	BF_GS1_DATABAR_LIMITED = 131072,
	BF_PATCHCODE = 262144,
	BF_PDF417 = 33554432,
	BF_QR_CODE = 67108864,
	BF_DATAMATRIX = 134217728,
	BF_AZTEC = 268435456,
	BF_MAXICODE = 536870912,
	BF_MICRO_QR = 1073741824,
	BF_MICRO_PDF417 = 524288,
	BF_GS1_COMPOSITE = -2147483648,
	BF_MSI_CODE = 1048576,
	BF_NULL = 0
}
/**
 * @see [C++ TextResult](https://www.dynamsoft.com/barcode-reader/programming/c-cplusplus/struct/TextResult.html?src=cpp&&ver=latest)
*/
interface TextResult {
	/**
	 * The barcode text.
	 */
	barcodeText: string;
	/**
	 * The barcode format.
	 */
	barcodeFormat: number | EnumBarcodeFormat;
	/**
	 * Barcode type in string.
	 */
	barcodeFormatString: string;
	/**
	 * The barcode content in a byte array.
	 */
	barcodeBytes: number[];
	/**
	 * The corresponding localization result.
	 */
	localizationResult: LocalizationResult;
}
interface RegionDefinition {
	regionBottom: number;
	regionRight: number;
	regionLeft: number;
	regionTop: number;
	regionMeasuredByPercentage: number | boolean;
}
declare enum EnumIntermediateResultType {
	IRT_NO_RESULT = 0,
	IRT_ORIGINAL_IMAGE = 1,
	IRT_COLOUR_CLUSTERED_IMAGE = 2,
	IRT_COLOUR_CONVERTED_GRAYSCALE_IMAGE = 4,
	IRT_TRANSFORMED_GRAYSCALE_IMAGE = 8,
	IRT_PREDETECTED_REGION = 16,
	IRT_PREPROCESSED_IMAGE = 32,
	IRT_BINARIZED_IMAGE = 64,
	IRT_TEXT_ZONE = 128,
	IRT_CONTOUR = 256,
	IRT_LINE_SEGMENT = 512,
	IRT_FORM = 1024,
	IRT_SEGMENTATION_BLOCK = 2048,
	IRT_TYPED_BARCODE_ZONE = 4096,
	IRT_PREDETECTED_QUADRILATERAL = 8192
}
declare enum EnumTerminatePhase {
	TP_REGION_PREDETECTED = 1,
	TP_IMAGE_PREPROCESSED = 2,
	TP_IMAGE_BINARIZED = 4,
	TP_BARCODE_LOCALIZED = 8,
	TP_BARCODE_TYPE_DETERMINED = 16,
	TP_BARCODE_RECOGNIZED = 32
}
declare enum EnumTextResultOrderMode {
	TROM_CONFIDENCE = 1,
	TROM_POSITION = 2,
	TROM_FORMAT = 4,
	TROM_SKIP = 0,
	TROM_REV = 2147483648
}
declare enum EnumBinarizationMode {
	BM_AUTO = 1,
	BM_LOCAL_BLOCK = 2,
	BM_SKIP = 0,
	BM_THRESHOLD = 4,
	BM_REV = 2147483648
}
declare enum EnumPDFReadingMode {
	PDFRM_RASTER = 1,
	PDFRM_AUTO = 2,
	PDFRM_VECTOR = 4,
	PDFRM_REV = 2147483648
}
declare enum EnumScaleUpMode {
	SUM_AUTO = 1,
	SUM_LINEAR_INTERPOLATION = 2,
	SUM_NEAREST_NEIGHBOUR_INTERPOLATION = 4,
	SUM_SKIP = 0,
	SUM_REV = 2147483648
}
declare enum EnumLocalizationMode {
	LM_SKIP = 0,
	LM_AUTO = 1,
	LM_CONNECTED_BLOCKS = 2,
	LM_LINES = 8,
	LM_STATISTICS = 4,
	LM_SCAN_DIRECTLY = 16,
	LM_STATISTICS_MARKS = 32,
	LM_STATISTICS_POSTAL_CODE = 64,
	LM_CENTRE = 128,
	LM_REV = 2147483648
}
declare enum EnumBarcodeFormat_2 {
	BF2_NULL = 0,
	BF2_POSTALCODE = 32505856,
	BF2_NONSTANDARD_BARCODE = 1,
	BF2_USPSINTELLIGENTMAIL = 1048576,
	BF2_POSTNET = 2097152,
	BF2_PLANET = 4194304,
	BF2_AUSTRALIANPOST = 8388608,
	BF2_RM4SCC = 16777216,
	BF2_DOTCODE = 2
}
declare enum EnumResultCoordinateType {
	RCT_PIXEL = 1,
	RCT_PERCENTAGE = 2
}
/**
 * @see [C++ RuntimeSettings](https://www.dynamsoft.com/barcode-reader/programming/c-cplusplus/struct/PublicRuntimeSettings.html?src=cpp&&ver=latest)
 */
interface RuntimeSettings {
	/**
	 * Sets the formats of the barcode in BarcodeFormat group 1 to be read. Barcode formats in BarcodeFormat group 1 can be combined.
	 * ```js
	 * let runtimeSettings = await reader.getRuntimeSettings();
	 * runtimeSettings.barcodeFormatIds = Dynamsoft.DBR.EnumBarcodeFormat.BF_ONED | Dynamsoft.DBR.EnumBarcodeFormat.BF_QR_CODE;
	 * await reader.updateRuntimeSettings(runtimeSettings);
	 * ```
	 */
	barcodeFormatIds: number | EnumBarcodeFormat;
	/**
	 * Sets the formats of the barcode in BarcodeFormat group 2 to be read. Barcode formats in BarcodeFormat group 1 can be combined.
	 */
	barcodeFormatIds_2: number | EnumBarcodeFormat_2;
	/**
	 * Sets the mode and priority for binarization.
	 */
	binarizationModes: EnumBinarizationMode[];
	/**
	 * Sets the degree of blurriness of the barcode.
	 */
	deblurLevel: number;
	/**
	 * Sets the number of barcodes expected to be detected for each image.
	 */
	expectedBarcodesCount: number;
	/**
	 * Sets the further modes.
	 */
	furtherModes: any;
	/**
	 * Sets which types of intermediate result to be kept for further reference. Intermediate result types can be combined.
	 */
	intermediateResultTypes: EnumIntermediateResultType;
	/**
	 * Sets the mode and priority for localization algorithms.
	 */
	localizationModes: number[] | EnumLocalizationMode[];
	/**
	 * Sets the range of barcode text length for barcodes search
	 */
	minBarcodeTextLength: number;
	/**
	 * The minimum confidence of the result
	 */
	minResultConfidence: number;
	/**
	 * Not available in JS. Sets the way to detect barcodes from a PDF file when using the DecodeFile method.
	 */
	PDFReadingMode: EnumPDFReadingMode;
	/**
	 * Sets the region definition including the regionTop, regionLeft, regionRight, regionBottom and regionMeasuredByPercentage.
	 *
	 * Experimental feature:
	 *
	 * In [BarcodeScanner](../BarcodeScanner.md), `region` can be an array. For example `region = [r0, r1, r2]`, 0th frame use `r0`, 1st use `r1`, 2nd use `r2`, 3rd use `r0`, and then loop like this.
	 */
	region: RegionDefinition;
	/**
	 * Specifies the format for the coordinates returned
	 */
	resultCoordinateType: number | EnumResultCoordinateType;
	/**
	 * Sets whether or not to return the clarity of the barcode zone.
	 */
	returnBarcodeZoneClarity: number;
	/**
	 * Sets the threshold for the image shrinking
	 */
	scaleDownThreshold: number;
	/**
	 * Sets the mode and priority to control the sampling methods of scale-up for linear barcode with small module sizes.
	 */
	scaleUpModes: EnumScaleUpMode[];
	/**
	 * Sets the phase where the algorithm stops.
	 */
	terminatePhase: EnumTerminatePhase;
	/**
	 * Sets the mode and priority for the order of the text results returned.
	 */
	textResultOrderModes: EnumTextResultOrderMode[];
	/**
	 * Sets the maximum amount of time (in milliseconds) that should be spent searching for a barcode per page.
	 * It does not include the time taken to load/decode an image (Tiff, PNG, etc) from disk into memory.
	 */
	timeout: number;
}
declare enum EnumImagePixelFormat {
	IPF_Binary = 0,
	IPF_BinaryInverted = 1,
	IPF_GrayScaled = 2,
	IPF_NV21 = 3,
	IPF_RGB_565 = 4,
	IPF_RGB_555 = 5,
	IPF_RGB_888 = 6,
	IPF_ARGB_8888 = 7,
	IPF_RGB_161616 = 8,
	IPF_ARGB_16161616 = 9,
	IPF_ABGR_8888 = 10,
	IPF_ABGR_16161616 = 11,
	IPF_BGR_888 = 12
}
declare enum EnumErrorCode {
	DBR_SYSTEM_EXCEPTION = 1,
	DBR_SUCCESS = 0,
	DBR_UNKNOWN = -10000,
	DBR_NO_MEMORY = -10001,
	DBR_NULL_REFERENCE = -10002,
	DBR_LICENSE_INVALID = -10003,
	DBR_LICENSE_EXPIRED = -10004,
	DBR_FILE_NOT_FOUND = -10005,
	DBR_FILETYPE_NOT_SUPPORTED = -10006,
	DBR_BPP_NOT_SUPPORTED = -10007,
	DBR_INDEX_INVALID = -10008,
	DBR_BARCODE_FORMAT_INVALID = -10009,
	DBR_CUSTOM_REGION_INVALID = -10010,
	DBR_MAX_BARCODE_NUMBER_INVALID = -10011,
	DBR_IMAGE_READ_FAILED = -10012,
	DBR_TIFF_READ_FAILED = -10013,
	DBR_QR_LICENSE_INVALID = -10016,
	DBR_1D_LICENSE_INVALID = -10017,
	DBR_DIB_BUFFER_INVALID = -10018,
	DBR_PDF417_LICENSE_INVALID = -10019,
	DBR_DATAMATRIX_LICENSE_INVALID = -10020,
	DBR_PDF_READ_FAILED = -10021,
	DBR_PDF_DLL_MISSING = -10022,
	DBR_PAGE_NUMBER_INVALID = -10023,
	DBR_CUSTOM_SIZE_INVALID = -10024,
	DBR_CUSTOM_MODULESIZE_INVALID = -10025,
	DBR_RECOGNITION_TIMEOUT = -10026,
	DBR_JSON_PARSE_FAILED = -10030,
	DBR_JSON_TYPE_INVALID = -10031,
	DBR_JSON_KEY_INVALID = -10032,
	DBR_JSON_VALUE_INVALID = -10033,
	DBR_JSON_NAME_KEY_MISSING = -10034,
	DBR_JSON_NAME_VALUE_DUPLICATED = -10035,
	DBR_TEMPLATE_NAME_INVALID = -10036,
	DBR_JSON_NAME_REFERENCE_INVALID = -10037,
	DBR_PARAMETER_VALUE_INVALID = -10038,
	DBR_DOMAIN_NOT_MATCHED = -10039,
	DBR_RESERVEDINFO_NOT_MATCHED = -10040,
	DBR_AZTEC_LICENSE_INVALID = -10041,
	DBR_LICENSE_DLL_MISSING = -10042,
	DBR_LICENSEKEY_NOT_MATCHED = -10043,
	DBR_REQUESTED_FAILED = -10044,
	DBR_LICENSE_INIT_FAILED = -10045,
	DBR_PATCHCODE_LICENSE_INVALID = -10046,
	DBR_POSTALCODE_LICENSE_INVALID = -10047,
	DBR_DPM_LICENSE_INVALID = -10048,
	DBR_FRAME_DECODING_THREAD_EXISTS = -10049,
	DBR_STOP_DECODING_THREAD_FAILED = -10050,
	DBR_SET_MODE_ARGUMENT_ERROR = -10051,
	DBR_LICENSE_CONTENT_INVALID = -10052,
	DBR_LICENSE_KEY_INVALID = -10053,
	DBR_LICENSE_DEVICE_RUNS_OUT = -10054,
	DBR_GET_MODE_ARGUMENT_ERROR = -10055,
	DBR_IRT_LICENSE_INVALID = -10056,
	DBR_MAXICODE_LICENSE_INVALID = -10057,
	DBR_GS1_DATABAR_LICENSE_INVALID = -10058,
	DBR_GS1_COMPOSITE_LICENSE_INVALID = -10059,
	DBR_DOTCODE_LICENSE_INVALID = -10061,
	DMERR_NO_LICENSE = -20000,
	DMERR_LICENSE_SYNC_FAILED = -20003,
	DMERR_TRIAL_LICENSE = -20010,
	DMERR_FAILED_TO_REACH_LTS = -20200
}
interface BarcodeReaderException extends Error {
	code?: EnumErrorCode;
}
/**
 * The `BarcodeReader` class is used for image decoding
 * Comparing to `BarcodeScanner`, the default decoding settings are more accurate but slower.
 * ```js
 * let pReader = null;
 * (async()=>{
 *     let reader = await (pReader = pReader || Dynamsoft.DBR.BarcodeReader.createInstance());
 *     let results = await reader.decode(imageSource);
 *     for(let result of results){
 *         console.log(result.barcodeText);
 *     }
 * })();
 * ```
 */
declare class BarcodeReader {
	private static _jsVersion;
	private static _jsEditVersion;
	protected static _version: string;
	/**
	 * Get the current version.
	*/
	static get version(): string;
	protected static _productKeys: string;
	static get productKeys(): string;
	/**
	 * Get or set the Dynamsoft Barcode Reader SDK product keys.
	 * ```js
	 * Dynamsoft.DBR.BarcodeReader.productKeys = "PRODUCT-KEYS";
	 * ```
	 * For convenience, you can set `productKeys` in `script` tag instead.
	 * ```html
	 * <script src="https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.js" data-productKeys="PRODUCT-KEYS"></script>
	 * ```
	 */
	static set productKeys(keys: string);
	static get handshakeCode(): string;
	/**
	 * Get or set the Dynamsoft Barcode Reader SDK handshake code. The `handshakeCode` is an alias of `productKeys`. Specifically refers to the key that requires **network** authentication.
	 * ```js
	 * Dynamsoft.DBR.BarcodeReader.handshakeCode = "123****-mytest";
	 * ```
	 * For convenience, you can set `handshakeCode` in `script` tag instead.
	 * ```html
	 * <script src="https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.js" data-handshakeCode="123****-mytest"></script>
	 * ```
	 */
	static set handshakeCode(keys: string);
	protected static _organizationID: string;
	static get organizationID(): string;
	/**
	 * Use organization ID to get authentication from network. Keep handshakeCode empty if you want to use default `handshake` of the organization.
	 * ```js
	 * Dynamsoft.DBR.BarcodeReader.organizationID = "123****";
	 * ```
	 * For convenience, you can set `organizationID` in `script` tag instead.
	 * ```html
	 * <script src="https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.js" data-organizationID="123****"></script>
	 * ```
	 * @see [[handshakeCode]]
	 */
	static set organizationID(value: string);
	/** @ignore */
	static _sessionPassword: string;
	/**
	 * Specify a password to protect the `Handshake Code` from abuse.
	 * ```js
	 * Dynamsoft.DBR.BarcodeReader.handshakeCode = "123****-mytest";
	 * Dynamsoft.DBR.BarcodeReader.sessionPassword = "@#$%****";
	 * ```
	 * Since js in the browser is plaintext, it is not safe to set a password. It is recommended that you bind the `domain` as `Validation field` in the [handshake settings in dynamsoft website](https://www.dynamsoft.com/lts/index.html#/handshakeCodes) or your self-hosted license server.
	 *
	 * In nodejs, password is meaningful.
	 * @see [[handshakeCode]]
	 */
	static set sessionPassword(value: string);
	static get sessionPassword(): string;
	/** @ignore */
	static _limitModules?: string[];
	/** @ignore */
	static _chargeWay?: string;
	/**
	 * modify from https://gist.github.com/2107/5529665
	 * @ignore
	 */
	static browserInfo: any;
	/**
	 * Detect environment and get a report.
	 * ```js
	 * console.log(Dynamsoft.DBR.BarcodeReader.detectEnvironment());
	 * // {"wasm":true, "worker":true, "getUserMedia":true, "camera":true, "browser":"Chrome", "version":90, "OS":"Windows"}
	 * ```
	 */
	static detectEnvironment(): Promise<any>;
	/** @ignore */
	static _workerName: string;
	protected static _engineResourcePath?: string;
	static get engineResourcePath(): string;
	/**
	 * Specify the Barcode Reader SDK engine (WASM) url. The SDK tries to automatically explore the engine location.
	 * If the auto-explored engine location is incorrect, you can manually specify the engine location.
	 * The property needs to be set before [[loadWasm]].
	 * ```js
	 * Dynamsoft.DBR.BarcodeReader.engineResourcePath = "https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/";
	 * await Dynamsoft.DBR.BarcodeReader.loadWasm();
	 * ```
	*/
	static set engineResourcePath(value: string);
	/** @ignore */
	protected static _licenseServer?: string[];
	static get licenseServer(): string[] | string;
	/**
	 * Specify the license server URL.
	*/
	static set licenseServer(value: string[] | string);
	private static _deviceFriendlyName;
	/**
	 * @ignore
	 */
	static get deviceFriendlyName(): string;
	/** @ignore */
	static set deviceFriendlyName(value: string);
	/**
	 * @ignore
	 */
	static _isShowRelDecodeTimeInResults: boolean;
	/**
	 * @ignore
	 */
	_canvasMaxWH: number;
	/**
	 * @ignore
	 */
	static _onLog: (message: any) => void;
	/**
	 * @ignore
	 */
	static _bWasmDebug: boolean;
	/**
	 * @ignore
	 */
	static _bNeverShowDialog: boolean;
	/**
	 * Whether to use full feature wasm. The api may change in later version.
	 * For web, `_bUseFullFeature` is false as default.
	 * For Node.js, `_bUseFullFeature` will not work, and BarcodeReader will always work on full feature.
	 * The property needs to be set before `loadWasm`.
	 * <pre>
	 * Compact wasm:
	 * oned + qr + pdf417 + datamatrix.
	 * ===
	 * Full wasm:
	 * all supported barcode format +
	 * high level deblur available (lv8, 9) +
	 * DPM +
	 * template API +
	 * intermediate results API
	 * ===
	 * e.g.:
	 * Use compact in video deocode (small, download and initialization fast).
	 * Use full in file decode (need high level deblur).
	 * </pre>
	 *
	 * ```js
	 * DBR.BarcodeReader._bUseFullFeature = true;
	 * await DBR.BarcodeReader.loadWasm();
	 * ```
	 */
	protected static __bUseFullFeature: boolean;
	static get _bUseFullFeature(): boolean;
	static set _bUseFullFeature(value: boolean);
	/** @ignore */
	static _dbrWorker: Worker;
	protected static _nextTaskID: number;
	protected static _taskCallbackMap: Map<number, (body: any) => void>;
	private static _loadWasmStatus;
	private static _loadWasmCallbackArr;
	/** @ignore */
	_instanceID: number;
	/** @ignore */
	bSaveOriCanvas: boolean;
	/**
	 * Whether to save the original image into canvas.
	 * ```js
	 * reader.ifSaveOriginalImageInACanvas = true;
	 * let results = await reader.decode(source);
	 * document.body.append(reader.getOriginalImageInACanvas());
	 * ```
	 */
	get ifSaveOriginalImageInACanvas(): boolean;
	set ifSaveOriginalImageInACanvas(value: boolean);
	/** @ignore */
	oriCanvas?: HTMLCanvasElement | OffscreenCanvas;
	/**
	 * The original canvas.
	 * ```js
	 * reader.ifSaveOriginalImageInACanvas = true;
	 * let results = await reader.decode(source);
	 * document.body.append(reader.getOriginalImageInACanvas());
	 * ```
	 */
	getOriginalImageInACanvas(): HTMLCanvasElement | OffscreenCanvas;
	/** @ignore  */
	_1dMinConfidence: number;
	/** @ignore */
	maxVideoCvsLength: number;
	protected videoCvses?: (HTMLCanvasElement | OffscreenCanvas)[];
	protected videoGlCvs?: HTMLCanvasElement | OffscreenCanvas;
	protected videoGl?: WebGLRenderingContext | WebGL2RenderingContext;
	protected glImgData?: Uint8Array;
	protected bFilterRegionInJs: boolean;
	protected userDefinedRegion: any;
	protected _region?: RegionDefinition | RegionDefinition[];
	protected set region(value: null | RegionDefinition | RegionDefinition[]);
	protected get region(): null | RegionDefinition | RegionDefinition[];
	/** @ignore */
	_timeStartDecode: any;
	/** @ignore */
	_timeEnterInnerDBR: any;
	/** @ignore */
	_timeGetMessage: any;
	/** @ignore */
	_bUseWebgl: boolean;
	/** @ignore */
	decodeRecords: any;
	/**
	 * @ignore A callback when wasm download success in browser environment.
	 */
	static _onWasmDownloaded: () => void;
	/**
	 * Check if the decoding module is loaded.
	 * @category Initialize and Destroy
	 */
	static isLoaded(): boolean;
	/**
	 * Indicates whether the instance has been destroyed.
	 */
	bDestroyed: boolean;
	isContextDestroyed(): boolean;
	/** @ignore */
	protected static _lastErrorCode: number;
	/** @ignore */
	static get lastErrorCode(): number;
	/** @ignore */
	protected static _lastErrorString: string;
	/** @ignore */
	static get lastErrorString(): string;
	/** @ignore */
	protected _setWarnnedEx: Set<string>;
	/** @ignore */
	protected _lastErrorCode: number;
	/** @ignore */
	get lastErrorCode(): number;
	/** @ignore */
	protected _lastErrorString: string;
	/** @ignore */
	get lastErrorString(): string;
	/** @ignore */
	_lastInnerDecodeDuration: number;
	private static _loadWasmErr;
	/**
	 * Before most operations, `loadWasm` needs to be excuted firstly.
	 * Most time, you do not need excute `loadWasm` manually. Because when you excute [[createInstance]], `loadWasm` will be excuted implicitly.
	 * Some properties can't be changed after `loadWasm`.
	 * Calling `loadWasm` in advance can avoid the long wait when `createInstance`.
	 * ```js
	 * window.addEventListener('DOMContentLoaded', (event) => {
	 *   DBR.BarcodeReader.loadWasm();
	 * });
	 * ```
	 * @category Initialize and Destroy
	 */
	static loadWasm(): Promise<void>;
	/**
	 * @param type "warn" or "error"
	 * @param content
	 * @returns
	 */
	protected static showDialog(type: string, content: string): Promise<void>;
	protected static createInstanceInWorker(bScanner?: boolean): Promise<number>;
	/**
	 * Create a `BarcodeReader` instance.
	 * ```
	 * let pReader = null;
	 * (async()=>{
	 *     let reader = await (pReader = pReader || Dynamsoft.DBR.BarcodeReader.createInstance());
	 * })();
	 * ```
	  * @category Initialize and Destroy
	 */
	static createInstance(): Promise<BarcodeReader>;
	/**
	 * Decode barcodes from a image.
	 *
	 * The main decoding method can accept a variety of data types, including binary data, images, base64 (with mime), urls, etc.
	 *
	 * The image format can be `png`, `jpeg`, `bmp`, `gif` and a few other (some browsers support `webp`, `tif`).
	 *
	 * ```js
	 * let results = await reader.decode(blob);
	 * for(let result of results){
	 *     console.log(result.barcodeText);
	 * }
	 *
	 * let results2 = await reader.decode(htmlImageElement);
	 * let results2 = await reader.decode(url);
	 *
	 * // like `data:image/png;base64,iV************`
	 * let results3 = await reader.decode(base64WithMime);
	 * ```
	 *
	 * And you can get a frame to decode from the `HTMLVideoElement`.
	 *
	 * ```js
	 * // The frame currently played will be decode.
	 * let results;
	 * try{
	 *   results = await reader.decode(htmlVideoElement);
	 * }catch(ex){
	 *   // If no frame in the video, will throw an exception.
	 * }
	 * ```
	 * If you need to continuously decode a video, you can use [BarcodeScanner](../BarcodeScanner/index.md) instead.
	 * @param source
	 * @category Decode
	 */
	decode(source: Blob | Buffer | ArrayBuffer | Uint8Array | Uint8ClampedArray | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | string): Promise<TextResult[]>;
	/**
	 * The decoding method can accept base64 with or without mime.
	 * e.g. `data:image/jpg;base64,Xfjshekk....` or `Xfjshekk...`.
	 * ```js
	 * let results = await reader.decodeBase64String(strBase64);
	 * for(let result of results){
	 *     console.log(result.barcodeText);
	 * }
	 * ```
	 * @param base64
	 * @category Decode
	 */
	decodeBase64String(base64: string): Promise<TextResult[]>;
	/**
	 * The decoding method can accept url. The url source need to be in the same domain or allowed cors.
	 * ```js
	 * let results = await reader.decodeUrl("./1.png");
	 * for(let result of results){
	 *     console.log(result.barcodeText);
	 * }
	 * ```
	 * @param url
	 * @category Decode
	 */
	decodeUrl(url: string): Promise<TextResult[]>;
	/**
	 * Decodes barcodes from the memory buffer containing image pixels in defined format.
	 * @ignore
	 */
	_decodeBuffer_Uint8Array(buffer: Uint8Array | Uint8ClampedArray, width: number, height: number, stride: number, format: EnumImagePixelFormat, config?: any): Promise<TextResult[]>;
	/**
	 *
	 * @param buffer
	 * @param width
	 * @param height
	 * @param stride
	 * @param format
	 * @param config
	 * @ignore
	 */
	_decodeBuffer_Blob(buffer: Blob, width: number, height: number, stride: number, format: EnumImagePixelFormat, config?: any): Promise<any>;
	/**
	 * Decode barcodes from raw image data.
	 * @param buffer
	 * @param width
	 * @param height
	 * @param stride
	 * @param format
	 * @param config
	 * @category Decode
	 */
	decodeBuffer(buffer: Uint8Array | Uint8ClampedArray | ArrayBuffer | Blob | Buffer, width: number, height: number, stride: number, format: EnumImagePixelFormat, config?: any): Promise<TextResult[]>;
	/** @ignore */
	_decodeFileInMemory_Uint8Array(bytes: Uint8Array): Promise<any>;
	/**
	 * Gets current runtime settings.
	 * ```js
	 * let settings = await reader.getRuntimeSettings();
	 * settings.deblurLevel = 5;
	 * await reader.updateRuntimeSettings(settings);
	 * ```
	 * @see [RuntimeSettings](https://www.dynamsoft.com/barcode-reader/programming/c-cplusplus/struct/PublicRuntimeSettings.html?ver=latest&utm_source=github&package=js)
	 * @category Runtime Settings
	 */
	getRuntimeSettings(): Promise<RuntimeSettings>;
	/**
	 * Update runtime settings with a given struct, or a string of `speed`, `balance` or `coverage` to use preset settings for BarcodeReader.
	 * The default settings for BarcodeReader is `coverage`.
	 * ```js
	 * await reader.updateRuntimeSettings('balance');
	 * let settings = await reader.getRuntimeSettings();
	 * settings.barcodeFormatIds = Dynamsoft.DBR.EnumBarcodeFormat.BF_ONED;
	 * await reader.updateRuntimeSettings(settings);
	 * ```
	 * @see [RuntimeSettings](https://www.dynamsoft.com/barcode-reader/programming/c-cplusplus/struct/PublicRuntimeSettings.html?ver=latest&utm_source=github&package=js)
	 * @category Runtime Settings
	 */
	updateRuntimeSettings(settings: RuntimeSettings | string): Promise<void>;
	/**
	 * Resets all parameters to default values.
	 * ```js
	 * await reader.resetRuntimeSettings();
	 * ```
	 * @category Runtime Settings
	 */
	resetRuntimeSettings(): Promise<void>;
	/**
	 * Outputs the license content as an encrypted string from the license server to be used for offline license verification.
	 * ```js
	 * let strSettings = await reader.outputSettingsToString();
	 * ```
	 * The method is only supported in the full feature edition.
	 * @ignore
	 * @category Runtime Settings
	 */
	outputSettingsToString(): Promise<string>;
	/**
	 * Initialize runtime settings with the settings in given JSON string.
	 * ```js
	 * await reader.initRuntimeSettingsWithString("{\"Version\":\"3.0\", \"ImageParameter\":{\"Name\":\"IP1\", \"BarcodeFormatIds\":[\"BF_QR_CODE\"], \"ExpectedBarcodesCount\":10}}");
	 * ```
	 * The method is only supported in the full feature edition.
	 * @ignore
	 * @category Runtime Settings
	 */
	initRuntimeSettingsWithString(settings: any): Promise<void>;
	private _decode_Blob;
	/**
	 *
	 * @param arrayBuffer
	 * @param config
	 * @ignore
	 */
	private _decode_ArrayBuffer;
	/**
	 *
	 * @param uint8Array
	 * @param config
	 * @ignore
	 */
	private _decode_Uint8Array;
	/**
	 *
	 * @param image
	 * @param config
	 * @ignore
	 */
	private _decode_Image;
	private _decode_Canvas;
	/**
	 *
	 * @param video
	 * @param config
	 * @ignore
	 */
	protected handleVideoFrame(video: HTMLVideoElement, config?: any): Object;
	/**
	 * decode video is not multi call safe in an instance, we reuse many thing for speed, so make sure wait util one finish then call next
	 * @param video
	 * @param config
	 * @ignore
	 */
	_decode_Video(video: HTMLVideoElement, config?: any): Promise<TextResult[]>;
	private _decode_Base64;
	private _decode_Url;
	private _decode_FilePath;
	/** @ignore */
	static fixResultLocationWhenFilterRegionInJs(region: any, results: TextResult[], sx: number, sy: number, sWidth: number, sHeight: number, dWidth: number, dHeight: number): void;
	/** @ignore */
	static BarcodeReaderException(ag0: any, ag1: any): BarcodeReaderException;
	protected _handleRetJsonString(objRet: any): any;
	/**
	 * Set argument value for the specified mode parameter.
	 * ```js
	 * await reader.setModeArgument("BinarizationModes", 0, "EnableFillBinaryVacancy", "1");
	 * ```
	 * @param modeName
	 * @param index
	 * @param argumentName
	 * @param argumentValue
	 * @category Runtime Settings
	 */
	setModeArgument(modeName: string, index: number, argumentName: string, argumentValue: string): Promise<void>;
	/**
	 * Get argument value for the specified mode parameter.
	 * ```js
	 * let argumentValue = await reader.getModeArgument("BinarizationModes", 0, "EnableFillBinaryVacancy");
	 * ```
	 * @param modeName
	 * @param index
	 * @param argumentName
	 * @category Runtime Settings
	 */
	getModeArgument(modeName: string, index: number, argumentName: string): Promise<string>;
	/**
	 * The method is only supported in the full feature edition.
	 * Returns intermediate results containing the original image, the colour clustered image, the binarized Image, contours, Lines, TextBlocks, etc.
	 * ```js
	 * let imResults = await reader.getIntermediateResults();
	 * ```
	 * @ignore
	 */
	getIntermediateResults(): Promise<any>;
	/** @ignore */
	getIntermediateCanvas(): Promise<HTMLCanvasElement[]>;
	/**
	 * Destroy the `BarcodeReader` instance. If your page needs to create new instances from time to time, don't forget to destroy unused old instances, otherwise it will cause memory leaks.
	 * @category Initialize and Destroy
	 */
	destroy(): Promise<void>;
}
interface FrameFilter {
	/**
	 * The region definition of the frame to calculate the internal indicator.
	 * Default Value: { regionLeft = 0, regionRight = 100, regionTop = 0, regionBottom = 100, regionMeasuredByPercentage = true }
	*/
	region?: RegionDefinition | any;
	/**
	 * The threshold used for filtering frames.
	 * Value range: [0, 1].
	 * Default value: 0.1.
	 * The SDK will calculate an inner indicator for each frame from AppendFrame(), if the change rate of the indicators between the current frame and the history frames is larger than the given threshold, the current frame will not be added to the inner frame queue waiting for decoding.
	 */
	threshold?: number;
}
/**
 * let scanSettings = await scanner.getScanSettings();
 * scanSettings.intervalTime = 100; // 100ms
 * scanSettings.duplicateForgetTime = 3000; // 3s
 * await scanner.updateScanSettings(scanSettings);
 */
interface ScanSettings {
	intervalTime?: number;
	duplicateForgetTime?: number;
	/**
	 * Filter frame during focusing.
	 * `region` define the detecting area.
	 * `threshold` is (0,1).
	 * ```js
	 * scanSettings.frameFilter = {
	 *      region: {
	 *          regionLeft: 0,
	 *          regionTop: 47,
	 *          regionRight: 100,
	 *          regionBottom: 53,
	 *          regionMeasuredByPercentage: true
	 *      },
	 *      threshold: 0.01
	 * };
	 * ```
	 */
	frameFilter?: FrameFilter;
}
interface VideoDeviceInfo {
	deviceId: string;
	label: string;
	/** @ignore */
	_checked: boolean;
}
interface ScannerPlayCallbackInfo {
	height: number;
	width: number;
}
/**
 * The `BarcodeScanner` class is used for video decoding.
 * ```js
 * let pScanner = null;
 * (async()=>{
 *     let scanner = await (pScanner = pScanner || Dynamsoft.DBR.BarcodeScanner.createInstance());
 *     scanner.onUnduplicatedRead = txt => console.log(txt);
 *     await scanner.show();
 * })();
 * ```
 */
declare class BarcodeScanner extends BarcodeReader {
	private static _defaultUIElementURL;
	static get defaultUIElementURL(): string;
	/**
	 * The url of the default scanner UI.
	 * Can only be changed before `createInstance`.
	 * ```js
	 * Dynamsoft.DBR.BarcodeScanner.defaultUIElementURL = "https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.scanner.html";
	 * let pScanner = null;
	 * (async()=>{
	 *     let scanner = await (pScanner = pScanner || Dynamsoft.DBR.BarcodeScanner.createInstance());
	 *     await scanner.show();
	 * })();
	 * ```
	 */
	static set defaultUIElementURL(value: string);
	/** @ignore */
	/** @ignore */
	UIElement: HTMLElement;
	/**
	 * Get HTML element containing the `BarcodeScanner` instance.
	 * @category UI
	 */
	getUIElement(): HTMLElement;
	/**
	 * Set html element containing the `BarcodeScanner` instance.
	 * ```html
	 * <video class="dbrScanner-video" playsinline="true"></video>
	 * <script>
	 *     let pScanner = null;
	 *     (async()=>{
	 *         let scanner = await (pScanner = pScanner || Dynamsoft.DBR.BarcodeScanner.createInstance());
	 *         await scanner.setUIElement(document.getElementsByClassName("dbrScanner-video")[0]);
	 *         await scanner.open();
	 *     })();
	 * </script>
	 * ```
	 * @param element
	 * @category UI
	 */
	setUIElement(elementOrUrl: HTMLElement | string): Promise<void>;
	/** @ignore */
	private styleEls;
	/** @ignore */
	videoSettings: MediaStreamConstraints;
	/** Set a existing video source for decoding. */
	videoSrc: string | MediaStream | MediaSource | Blob;
	private _singleFrameMode;
	/**
	 * A mode not use video, get a frame from OS camera instead.
	 * ```js
	 * let pScanner = null;
	 * (async()=>{
	 *     let scanner = await (pScanner = pScanner || Dynamsoft.DBR.BarcodeScanner.createInstance());
	 *     if(scanner.singleFrameMode){
	 *         // the browser does not provide webrtc API, dbrjs automatically use singleFrameMode instead
	 *         scanner.show();
	 *     }
	 * })();
	 * ```
	 */
	get singleFrameMode(): boolean;
	/**
	 * A mode not use video, get a frame from OS camera instead.
	 * ```js
	 * let pScanner = null;
	 * (async()=>{
	 *     let scanner = await (pScanner = pScanner || Dynamsoft.DBR.BarcodeScanner.createInstance());
	 *     scanner.singleFrameMode = true; // use singleFrameMode anyway
	 *     scanner.show();
	 * })();
	 * ```
	 */
	set singleFrameMode(value: boolean);
	private _singleFrameModeIpt;
	private _clickIptSingleFrameMode;
	/** @ignore */
	intervalTime: number;
	private _isOpen;
	private _assertOpen;
	/** @ignore */
	private _bWorkerDecodeBuffer;
	/** @ignore */
	private _idGetFrameTimeout;
	/** @ignore */
	private _idGetFrameTimeout2;
	/** @ignore */
	private _intervalGetVideoFrame;
	/**
	 * 0: get frame after worker finished decoding(original version).
	 * 1: get frame and push them to queue when worker is decoding and the queue is empty, which can help next loop skip the getting frame process.
	 * 2: continously get frame and push it to queue, which can help next loop skip the getting frame process.
	 * 4: get frame and push them to queue when worker is decoding and the queue is empty, which can help next loop skip the getting frame process. Different from mode 1, there is a interval time before getting frame.
	 * @ignore
	*/
	private _getVideoFrameMode;
	/**
	 * @ignore
	 * the times of loop get frame
	 */
	private loopGetFrameTimes;
	/** @ignore */
	private _countLoopGetFrame;
	/** @ignore */
	private queue_handledFrame;
	/** @ignore */
	private array_getFrameTimeCost;
	/** @ignore */
	private array_decodeFrameTimeCost;
	/** @ignore */
	private _indexCurrentDecodingFrame;
	/** @ignore */
	_timeEndGettingFrame: any;
	private _bPauseScan;
	/** @ignore */
	_lastDeviceId: string;
	private _intervalDetectVideoPause;
	private _vc_bPlayingVideoBeforeHide;
	private _ev_documentHideEvent;
	/** @ignore */
	_video: HTMLVideoElement;
	/** @ignore */
	_cvsDrawArea: HTMLCanvasElement;
	/** @ignore */
	_divScanArea: any;
	/** @ignore */
	_divScanLight: any;
	/** @ignore */
	_bgLoading: any;
	/** @ignore */
	_bgCamera: any;
	/** @ignore */
	_selCam: any;
	/** @ignore */
	_selRsl: any;
	/** @ignore */
	_optGotRsl: any;
	/** @ignore */
	_btnClose: any;
	/** @ignore */
	private _soundOnSuccessfullRead;
	/**
	 * The sound to play when the scanner get successfull read.
	 */
	get soundOnSuccessfullRead(): HTMLAudioElement;
	/**
	 * The sound to play when the scanner get successfull read.
	 * ```js
	 * scanner.soundOnSuccessfullRead = new Audio("./pi.mp3");
	 * ```
	 */
	set soundOnSuccessfullRead(value: HTMLAudioElement);
	/**
	 * Whether to play sound when the scanner reads a barcode successfully.
	 * Default value is `false`, which does not play sound.
	 * Use `frame` or `true` to play a sound when any barcode is found within a frame.
	 * Use `unduplicated` to play a sound only when any unique/unduplicated barcode is found within a frame.
	 * ```js
	 * // A user gesture required. https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
	 * startPlayButton.addEventListener('click', function() {
	 *   scanner.bPlaySoundOnSuccessfulRead = true;
	 * });
	 * ```
	 * refer: `favicon bug` https://bugs.chromium.org/p/chromium/issues/detail?id=1069731&q=favicon&can=2
	 * @ignore
	 */
	bPlaySoundOnSuccessfulRead: (boolean | string);
	get whenToPlaySoundforSuccessfulRead(): string;
	/**
	 * Whether to play sound when the scanner reads a barcode successfully.
	 * Default value is `never`, which does not play sound.
	 * Use `frame` to play a sound when any barcode is found within a frame.
	 * Use `unduplicated` to play a sound only when any unique/unduplicated barcode is found within a frame.
	 * ```js
	 * // A user gesture required. https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
	 * startPlayButton.addEventListener('click', function() {
	 *   scanner.whenToPlaySoundforSuccessfulRead = 'frame';
	 * });
	 * ```
	 * refer: `favicon bug` https://bugs.chromium.org/p/chromium/issues/detail?id=1069731&q=favicon&can=2
	 */
	set whenToPlaySoundforSuccessfulRead(value: string);
	/**
	 * Whether to vibrate when the scanner reads a barcode successfully.
	 * Default value is `false`, which does not vibrate.
	 * Use `frame` or `true` to vibrate when any barcode is found within a frame.
	 * Use `unduplicated` to vibrate only when any unique/unduplicated barcode is found within a frame.
	 * ```js
	 * // Can I use? https://caniuse.com/?search=vibrate
	 * // A user gesture required. https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
	 * startVibrateButton.addEventListener('click', function() {
	 *   scanner.bVibrateOnSuccessfulRead = true;
	 * });
	 * ```
	 * @ignore
	 */
	bVibrateOnSuccessfulRead: (boolean | string);
	/**
	 * Get or set how long (ms) the vibration lasts.
	 * @see [[bVibrateOnSuccessfulRead]],[[whenToVibrateforSuccessfulRead]]
	 */
	vibrateDuration: number;
	get whenToVibrateforSuccessfulRead(): string;
	/**
	 * Whether to vibrate when the scanner reads a barcode successfully.
	 * Default value is `never`, which does not vibrate.
	 * Use `frame` to vibrate when any barcode is found within a frame.
	 * Use `unduplicated` to vibrate only when any unique/unduplicated barcode is found within a frame.
	 * ```js
	 * // Can I use? https://caniuse.com/?search=vibrate
	 * // A user gesture required. https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#chrome_enterprise_policies
	 * startPlayButton.addEventListener('click', function() {
	 *   scanner.whenToVibrateforSuccessfulRead = 'frame';
	 * });
	 * ```
	 */
	set whenToVibrateforSuccessfulRead(value: string);
	/** @ignore */
	_allCameras: VideoDeviceInfo[];
	/** @ignore */
	_currentCamera?: VideoDeviceInfo;
	/** @ignore */
	_videoTrack: MediaStreamTrack;
	/**
	 * Set the style used when filling the mask beyond the region.
	 * @category UI
	 */
	regionMaskFillStyle: string;
	/**
	 * Set the style of the region border.
	 * @category UI
	 */
	regionMaskStrokeStyle: string;
	/**
	 * Set the width of the region border.
	 * @category UI
	 */
	regionMaskLineWidth: number;
	/**
	 * Set the style used when filling in located barcode.
	 * @category UI
	 */
	barcodeFillStyle: string;
	/**
	 * Set the style of the located barcode border.
	 * @category UI
	 */
	barcodeStrokeStyle: string;
	/**
	 * Set the width of the located barcode border.
	 * @category UI
	 */
	barcodeLineWidth: number;
	protected beingLazyDrawRegionsults: boolean;
	protected set region(value: null | RegionDefinition | RegionDefinition[]);
	protected get region(): null | RegionDefinition | RegionDefinition[];
	protected _indexVideoRegion: number;
	/** @ignore */
	constructor();
	/**
	 * Create a `BarcodeScanner` object.
	* ```
	* let pScanner = null;
	* (async()=>{
	*     let scanner = await (pScanner = pScanner || Dynamsoft.DBR.BarcodeScanner.createInstance());
	* })();
	* ```
	 * @param config
	 * @category Initialize and Destroy
	 */
	static createInstance(config?: any): Promise<BarcodeScanner>;
	/** @ignore */
	decode(source: Blob | ArrayBuffer | Uint8Array | Uint8ClampedArray | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | string): Promise<TextResult[]>;
	/** @ignore */
	decodeBase64String(source: string): Promise<TextResult[]>;
	/** @ignore */
	decodeUrl(source: string): Promise<TextResult[]>;
	/** @ignore */
	decodeBuffer(buffer: Uint8Array | Uint8ClampedArray | ArrayBuffer | Blob, width: number, height: number, stride: number, format: EnumImagePixelFormat, config?: any): Promise<any>;
	/**
	 * Decode barcodes from the current frame of the video.
	 * ```js
	 * await scanner.showVideo();
	 * console.log(await scanner.decodeCurrentFrame());
	 * ```
	 * @category Decode
	 */
	decodeCurrentFrame(config?: any): Promise<TextResult[]>;
	private clearMapDecodeRecord;
	private static readonly singlePresetRegion;
	private static isRegionSinglePreset;
	private static isRegionNormalPreset;
	/**
	 * Update runtime settings with a given struct, or a string of `speed`, `balance`, `coverage` and `single` to use preset settings for BarcodeScanner.
	 * We recommend using the speed-optimized `single` preset if scanning only one barcode at a time. The `single` is only available in `BarcodeScanner`.
	 * The default settings for BarcodeScanner is `single`.
	 * ```js
	 * await scanner.updateRuntimeSettings('balance');
	 * let settings = await scanner.getRuntimeSettings();
	 * settings.barcodeFormatIds = Dynamsoft.DBR.EnumBarcodeFormat.BF_ONED;
	 * await scanner.updateRuntimeSettings(settings);
	 * ```
	 * @see [RuntimeSettings](https://www.dynamsoft.com/barcode-reader/programming/c-cplusplus/struct/PublicRuntimeSettings.html?ver=latest&utm_source=github&package=js)
	 * @category Runtime Settings
	 */
	updateRuntimeSettings(settings: RuntimeSettings | string): Promise<void>;
	/** @ignore */
	_onCameraSelChange: () => void;
	/** @ignore */
	_onResolutionSelChange: () => void;
	/** @ignore */
	_onCloseBtnClick: () => void;
	/** @ignore */
	_bindUI(): void;
	/** @ignore */
	_unbindUI(): void;
	/**
	 * Triggered when the camera video stream is played.
	 * ```js
	 * scanner.onplayed = rsl=>{ console.log(rsl.width+'x'+rsl.height) };
	 * await scanner.show(); // or open, play, setCurrentCamera, like these.
	 * ```
	 */
	onPlayed?: (info: ScannerPlayCallbackInfo) => void;
	/**
	 * The event is triggered after a frame has been scanned.
	 * The results object contains all the barcode results in this frame.
	 * ```js
	 * scanner.onFrameRead = results => {
	 *     for(let result of results){
	 *         console.log(result.barcodeText);
	 *     }
	 * };
	 * ```
	 */
	onFrameRead?: (results: TextResult[]) => void;
	/**
	 * This event is triggered when a new, unduplicated barcode is found.
	 * `txt` holds the barcode text result. `result` contains more info.
	 * Old barcodes will be remembered for `duplicateForgetTime`.
	 * ```js
	 * scanner.onUnduplicatedRead = (txt, result) => {
	 *     alert(txt);
	 *     console.log(result);
	 * };
	 * ```
	 */
	onUnduplicatedRead?: (txt: string, result: TextResult) => void;
	/** @ignore */
	private _renderSelCameraInfo;
	/**
	 * Get infomation of all available cameras on the device.
	 * ```js
	 * let cameras = await scanner.getAllCameras();
	 * if(cameras.length){
	 *     await scanner.setCurrentCamera(cameras[0]);
	 * }
	 * ```
	 * @category Camera Settings
	 */
	getAllCameras(): Promise<VideoDeviceInfo[]>;
	/**
	 * Get information about the currently used camera.
	 * ```js
	 * let camera = await scanner.getCurrentCamera();
	 * ```
	 * @category Camera Settings
	 */
	getCurrentCamera(): Promise<VideoDeviceInfo | null>;
	/**
	 * Choose the camera and play it by its information or devide id.
	 * ```js
	 * let cameras = await scanner.getAllCameras();
	 * if(cameras.length){
	 *     await scanner.setCurrentCamera(cameras[0]);
	 * }
	 * ```
	 * @param cameraInfoOrDeviceId
	 * @event [[onPlayed]]
	 * @category Camera Settings
	 */
	setCurrentCamera(cameraInfoOrDeviceId: any): Promise<ScannerPlayCallbackInfo>;
	/**
	 * Get current camera resolution.
	 * ```js
	 * let rsl = await scanner.getResolution();
	 * console.log(rsl.width + " x " + rsl.height);
	 * ```
	 * @category Camera Settings
	 */
	getResolution(): number[];
	/**
	 * Set current camera resolution.
	 * ```js
	 * await scanner.setResolution(width, height);
	 * ```
	 * @param width
	 * @param height
	 * @event [[onPlayed]]
	 * @category Camera Settings
	 */
	setResolution(width: number | number[], height: number): Promise<ScannerPlayCallbackInfo>;
	/**
	 * Get current scan settings.
	 * ```js
	 * let scanSettings = await scanner.getScanSettings();
	 * scanSettings.intervalTime = 50;
	 * scanSettings.duplicateForgetTime = 1000;
	 * await scanner.updateScanSettings(scanSettings);
	 * ```
	 */
	getScanSettings(): Promise<ScanSettings>;
	/**
	 * Modify and update scan settings.
	 * ```js
	 * let scanSettings = await scanner.getScanSettings();
	 * scanSettings.intervalTime = 50;
	 * scanSettings.duplicateForgetTime = 1000;
	 * await scanner.updateScanSettings(scanSettings);
	 * ```
	 * @param settings
	 */
	updateScanSettings(settings: ScanSettings): Promise<void>;
	/**
	 * Get current video settings.
	 * @category Camera Settings
	 */
	getVideoSettings(): MediaStreamConstraints;
	/**
	 * Modify and update video settings.
	 * ```js
	 * await scanner.updateVideoSettings({ video: {width: {ideal: 1280}, height: {ideal: 720}, facingMode: {ideal: 'environment'}} });
	 * ```
	 * @param MediaStreamConstraints
	 * @category Camera Settings
	 */
	updateVideoSettings(MediaStreamConstraints: any): Promise<ScannerPlayCallbackInfo | void>;
	/**
	 * Check if the scanner is open.
	 * ```js
	 * await scanner.show(); // or open(), showVideo(), openVideo();
	 * console.assert(scanner.isOpen(), "scanner should be opened.");
	 * await scanner.hide(); // or close();
	 * console.assert(!scanner.isOpen(), "scanner should be closed.");
	 * ```
	 * @category Open and Close
	 */
	isOpen(): boolean;
	/** @ignore */
	_show(): void;
	/**
	 * Stop the video, and release the camera.
	 * ```js
	 * scanner.stop()
	 * \\*** a lot of work ***
	 * await scanner.play();
	 * ```
	 * @category Play and Pause
	 */
	stop(): void;
	/**
	 * Pause the video. Do not release the camera.
	 * ```js
	 * scanner.pause();
	 * \\*** a lot of work ***
	 * await scanner.play();
	 * ```
	 * @category Play and Pause
	 */
	pause(): void;
	private iPlayRound;
	private promisePlay;
	/**
	 * Continue the video.
	 * ```js
	 * scanner.pause(); // or scanner.stop()
	 * \\*** a lot of work ***
	 * await scanner.play();
	 * ```
	 * @event [[onPlayed]]
	 * @category Play and Pause
	 */
	play(deviceId?: string, width?: number, height?: number): Promise<ScannerPlayCallbackInfo>;
	/**
	 * Pause the decoding process.
	 * ```js
	 * pauseScan();
	 * \\*** a lot of work ***
	 * resumeScan();
	 * ```
	 * @category Play and Pause
	 */
	pauseScan(): void;
	/**
	 * Resume the decoding process.
	 * ```js
	 * pauseScan();
	 * \\*** a lot of work ***
	 * resumeScan();
	 * ```
	 * @category Play and Pause
	 */
	resumeScan(): void;
	/**
	 * Get the camera capabilities. Chrome only.
	 * Only available when the scanner is open.
	 * ```console
	 * > scanner.getCapabilities()
	 * < {
	 *   "aspectRatio":{"max":3840,"min":0.000462962962962963},
	 *   "colorTemperature":{max: 7000, min: 2850, step: 50},
	 *   "deviceId":"1e...3af7",
	 *   "exposureCompensation": {max: 2.0000040531158447, min: -2.0000040531158447, step: 0.16666699945926666},
	 *   "exposureMode":["continuous","manual"],
	 *   "facingMode":["environment"],
	 *   "focusMode":["continuous","single-shot","manual"],
	 *   "frameRate":{"max":30,"min":0},
	 *   "groupId":"71...a935",
	 *   "height":{"max":2160,"min":1},
	 *   "resizeMode":["none","crop-and-scale"],
	 *   "torch":true,
	 *   "whiteBalanceMode":["continuous","manual"],
	 *   "width":{"max":3840,"min":1},
	 *   "zoom":{max: 606, min: 100, step: 2}
	 * }
	 * ```
	 * @see [[turnOnTorch]],[[turnOffTorch]],[[setExposureCompensation]],[[setZoom]]
	 * @category Camera Settings
	 */
	getCapabilities(): MediaTrackCapabilities;
	/** @ignore */
	getCameraSettings(): MediaTrackSettings;
	/** @ignore */
	getConstraints(): MediaTrackConstraints;
	/**
	 * @ignore
	 * Set the camera capabilities. Chrome only.
	 * Only available when the scanner is open.
	 * It's a low-level API, usually you can use the wrapped APIs instead.
	 * ```js
	 * await scanner.applyConstraints({ frameRate: { ideal:5 } });
	 * ```
	 */
	applyConstraints(constraints: MediaTrackConstraints): Promise<void>;
	/**
	 * Turn on the torch/flashlight. Chrome only.
	 * Only available when the scanner is open.
	 * Will reject if not support.
	 * ```js
	 * await scanner.turnOnTorch();
	 * ```
	 * @see [[turnOffTorch]],[[getCapabilities]]
	 * @category Camera Settings
	 */
	turnOnTorch(): Promise<void>;
	/**
	 * Turn off the torch. Chrome only.
	 * Only available when the scanner is open.
	 * Will reject if not support.
	 * ```js
	 * await scanner.turnOffTorch();
	 * ```
	 * @see [[turnOnTorch]],[[getCapabilities]]
	 * @category Camera Settings
	 */
	turnOffTorch(): Promise<void>;
	/**
	 * Adjusts the color temperature. Chrome only.
	 * Only available when the scanner is open.
	 * Will reject if not support.
	 * ```js
	 * await scanner.setColorTemperature(5000);
	 * ```
	 * @see [[getCapabilities]]
	 * @category Camera Settings
	 */
	setColorTemperature(value: number): Promise<void>;
	/**
	 * Adjusts the exposure level. Chrome only.
	 * Only available when the scanner is open.
	 * Will reject if not support.
	 * ```js
	 * await scanner.setExposureCompensation(-0.7);
	 * ```
	 * @see [[getCapabilities]]
	 * @category Camera Settings
	 */
	setExposureCompensation(value: number): Promise<void>;
	/**
	 * Adjusts the zoom ratio. Chrome only.
	 * Only available when the scanner is open.
	 * Will reject if not support.
	 * ```js
	 * await scanner.setZoom(400);
	 * ```
	 * @see [[getCapabilities]]
	 * @category Camera Settings
	 */
	setZoom(value: number): Promise<void>;
	/**
	 * Adjusts the frame rate. Chrome only.
	 * Only available when the scanner is open.
	 * Will reject if not support.
	 * ```js
	 * await scanner.setFrameRate(10);
	 * ```
	 * @see [[getCapabilities]]
	 * @category Camera Settings
	 */
	setFrameRate(value: number): Promise<void>;
	/** @ignore */
	_cloneDecodeResults(results: any): any;
	/**
	 * process of getting frame and decoding the frame
	 *
	 *                   <-------------
	 *                  |              ↑
	 *                  |              |
	 *              <--------          |
	 *            ↙          ↖         |
	 *           | get frame  |        |
	 *            ↘          ↗         |
	 *              -------->          |
	 *                   |             |
	 *                   ↓             |
	 *                decode --------->
	 *
	 * @ignore
	 * */
	private _loopReadVideo;
	/** @ignore */
	private loopGetVideoFrame;
	/** @ignore */
	_drawRegionsults(results?: TextResult[]): void;
	/** @ignore */
	_clearRegionsults(): void;
	/**
	 * Bind UI, open the camera, start decoding.
	 * ```js
	 * await scanner.setUIElement(document.getElementById("my-barcode-scanner"));
	 * scanner.onUnduplicatedRead = (txt, result) => { alert(txt); console.log(result); };
	 * await scanner.open();
	 * // await scanner.close();
	 * ```
	 * @event [[onPlayed]],[[onUnduplicatedRead]],[[onFrameRead]]
	 * @category Open and Close
	 */
	open(): Promise<ScannerPlayCallbackInfo>;
	/**
	 * Bind UI, open the camera, but not decode.
	 * ```js
	 * await scanner.setUIElement(document.getElementById("my-barcode-scanner"));
	 * await scanner.openVideo();
	 * console.log(await scanner.decodeCurrentFrame());
	 * // await scanner.close();
	 * ```
	 * @event [[onPlayed]],[[onUnduplicatedRead]],[[onFrameRead]]
	 * @category Open and Close
	 */
	openVideo(): Promise<ScannerPlayCallbackInfo>;
	/**
	 * Stop decoding, release camera, unbind UI.
	 * ```js
	 * await scanner.open();
	 * await scanner.close();
	 * ```
	 * ```js
	 * await scanner.openVideo();
	 * await scanner.close();
	 * ```
	 * @category Open and Close
	 */
	close(): Promise<void>;
	/**
	 * Bind UI, open the camera, start decoding, and remove the UIElement `display` style if the original style is `display:none;`.
	 * ```js
	 * await scanner.setUIElement("https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.scanner.html");
	 * scanner.onUnduplicatedRead = (txt, result) => { alert(txt); console.log(result); };
	 * await scanner.show();
	 * // await scanner.hide();
	 * ```
	 * @event [[onPlayed]],[[onUnduplicatedRead]],[[onFrameRead]]
	 * @category Open and Close
	 */
	show(): Promise<ScannerPlayCallbackInfo>;
	/**
	 * Bind UI, open the camera, but not decode, and remove the UIElement `display` style if the original style is `display:none;`.
	 * ```js
	 * await scanner.showVideo()
	 * console.log(await scanner.decodeCurrentFrame());
	 * // await scanner.hide();
	 * ```
	 * @event [[onPlayed]],[[onUnduplicatedRead]],[[onFrameRead]]
	 * @category Open and Close
	 */
	showVideo(): Promise<ScannerPlayCallbackInfo>;
	/**
	 * Stop decoding, release camera, unbind UI, and set the Element as `display:none;`.
	 * ```js
	 * await scanner.show();
	 * await scanner.hide();
	 * ```
	 * ```js
	 * await scanner.showVideo();
	 * await scanner.hide();
	 * ```
	 * @category Open and Close
	 */
	hide(): Promise<void>;
	/**
	 * Destroy the `BarcodeScanner` instance. If your page needs to create new instances from time to time, don't forget to destroy unused old instances, otherwise it will cause memory leaks.
	 * @category Initialize and Destroy
	 */
	destroy(): Promise<any>;
}
declare enum EnumBarcodeColourMode {
	BICM_DARK_ON_LIGHT = 1,
	BICM_LIGHT_ON_DARK = 2,
	BICM_DARK_ON_DARK = 4,
	BICM_LIGHT_ON_LIGHT = 8,
	BICM_DARK_LIGHT_MIXED = 16,
	BICM_DARK_ON_LIGHT_DARK_SURROUNDING = 32,
	BICM_SKIP = 0,
	BICM_REV = 2147483648
}
declare enum EnumBarcodeComplementMode {
	BCM_AUTO = 1,
	BCM_GENERAL = 2,
	BCM_SKIP = 0,
	BCM_REV = 2147483648
}
declare enum EnumClarityCalculationMethod {
	ECCM_CONTRAST = 1
}
declare enum EnumClarityFilterMode {
	CFM_GENERAL = 1
}
declare enum EnumColourClusteringMode {
	CCM_AUTO = 1,
	CCM_GENERAL_HSV = 2,
	CCM_SKIP = 0,
	CCM_REV = 2147483648
}
declare enum EnumColourConversionMode {
	CICM_GENERAL = 1,
	CICM_SKIP = 0,
	CICM_REV = 2147483648
}
declare enum EnumConflictMode {
	CM_IGNORE = 1,
	CM_OVERWRITE = 2
}
declare enum EnumDeblurMode {
	DM_SKIP = 0,
	DM_DIRECT_BINARIZATION = 1,
	DM_THRESHOLD_BINARIZATION = 2,
	DM_GRAY_EQUALIZATION = 4,
	DM_SMOOTHING = 8,
	DM_MORPHING = 16,
	DM_DEEP_ANALYSIS = 32,
	DM_SHARPENING = 64,
	DM_BASED_ON_LOC_BIN = 128,
	DM_SHARPENING_SMOOTHING = 256
}
declare enum EnumDeformationResistingMode {
	DRM_AUTO = 1,
	DRM_GENERAL = 2,
	DRM_SKIP = 0,
	DRM_REV = 2147483648
}
declare enum EnumDPMCodeReadingMode {
	DPMCRM_AUTO = 1,
	DPMCRM_GENERAL = 2,
	DPMCRM_SKIP = 0,
	DPMCRM_REV = 2147483648
}
declare enum EnumGrayscaleTransformationMode {
	GTM_INVERTED = 1,
	GTM_ORIGINAL = 2,
	GTM_SKIP = 0,
	GTM_REV = 2147483648
}
declare enum EnumImagePreprocessingMode {
	IPM_AUTO = 1,
	IPM_GENERAL = 2,
	IPM_GRAY_EQUALIZE = 4,
	IPM_GRAY_SMOOTH = 8,
	IPM_SHARPEN_SMOOTH = 16,
	IPM_MORPHOLOGY = 32,
	IPM_SKIP = 0,
	IPM_REV = 2147483648
}
declare enum EnumIMResultDataType {
	IMRDT_IMAGE = 1,
	IMRDT_CONTOUR = 2,
	IMRDT_LINESEGMENT = 4,
	IMRDT_LOCALIZATIONRESULT = 8,
	IMRDT_REGIONOFINTEREST = 16,
	IMRDT_QUADRILATERAL = 32
}
declare enum EnumIntermediateResultSavingMode {
	IRSM_MEMORY = 1,
	IRSM_FILESYSTEM = 2,
	IRSM_BOTH = 4
}
declare enum EnumQRCodeErrorCorrectionLevel {
	QRECL_ERROR_CORRECTION_H = 0,
	QRECL_ERROR_CORRECTION_L = 1,
	QRECL_ERROR_CORRECTION_M = 2,
	QRECL_ERROR_CORRECTION_Q = 3
}
declare enum EnumRegionPredetectionMode {
	RPM_AUTO = 1,
	RPM_GENERAL = 2,
	RPM_GENERAL_RGB_CONTRAST = 4,
	RPM_GENERAL_GRAY_CONTRAST = 8,
	RPM_GENERAL_HSV_CONTRAST = 16,
	RPM_SKIP = 0,
	RPM_REV = 2147483648
}
declare enum EnumResultType {
	RT_STANDARD_TEXT = 0,
	RT_RAW_TEXT = 1,
	RT_CANDIDATE_TEXT = 2,
	RT_PARTIAL_TEXT = 3
}
declare enum EnumTextFilterMode {
	TFM_AUTO = 1,
	TFM_GENERAL_CONTOUR = 2,
	TFM_SKIP = 0,
	TFM_REV = 2147483648
}
declare enum EnumTextureDetectionMode {
	TDM_AUTO = 1,
	TDM_GENERAL_WIDTH_CONCENTRATION = 2,
	TDM_SKIP = 0,
	TDM_REV = 2147483648
}
declare class DBR {
	/**
	 * The `BarcodeReader` class is used for image decoding
	 * Comparing to `BarcodeScanner`, the default decoding settings are more accurate but slower.
	 * ```js
	 * let pReader = null;
	 * (async()=>{
	 *     let reader = await (pReader = pReader || Dynamsoft.DBR.BarcodeReader.createInstance());
	 *     let results = await reader.decode(imageSource);
	 *     for(let result of results){
	 *         console.log(result.barcodeText);
	 *     }
	 * })();
	 * ```
	 */
	static BarcodeReader: typeof BarcodeReader;
	/**
	 * The `BarcodeScanner` class is used for video decoding.
	 * ```js
	 * let pScanner = null;
	 * (async()=>{
	 *     let scanner = await (pScanner = pScanner || Dynamsoft.DBR.BarcodeScanner.createInstance());
	 *     scanner.onUnduplicatedRead = txt => console.log(txt);
	 *     await scanner.show();
	 * })();
	 * ```
	 */
	static BarcodeScanner: typeof BarcodeScanner;
	static EnumBarcodeColourMode: typeof EnumBarcodeColourMode;
	static EnumBarcodeComplementMode: typeof EnumBarcodeComplementMode;
	static EnumBarcodeFormat: typeof EnumBarcodeFormat;
	static EnumBarcodeFormat_2: typeof EnumBarcodeFormat_2;
	static EnumBinarizationMode: typeof EnumBinarizationMode;
	static EnumClarityCalculationMethod: typeof EnumClarityCalculationMethod;
	static EnumClarityFilterMode: typeof EnumClarityFilterMode;
	static EnumColourClusteringMode: typeof EnumColourClusteringMode;
	static EnumColourConversionMode: typeof EnumColourConversionMode;
	static EnumConflictMode: typeof EnumConflictMode;
	static EnumDeblurMode: typeof EnumDeblurMode;
	static EnumDeformationResistingMode: typeof EnumDeformationResistingMode;
	static EnumDPMCodeReadingMode: typeof EnumDPMCodeReadingMode;
	static EnumErrorCode: typeof EnumErrorCode;
	static EnumGrayscaleTransformationMode: typeof EnumGrayscaleTransformationMode;
	static EnumImagePixelFormat: typeof EnumImagePixelFormat;
	static EnumImagePreprocessingMode: typeof EnumImagePreprocessingMode;
	static EnumIMResultDataType: typeof EnumIMResultDataType;
	static EnumIntermediateResultSavingMode: typeof EnumIntermediateResultSavingMode;
	static EnumIntermediateResultType: typeof EnumIntermediateResultType;
	static EnumLocalizationMode: typeof EnumLocalizationMode;
	static EnumPDFReadingMode: typeof EnumPDFReadingMode;
	static EnumQRCodeErrorCorrectionLevel: typeof EnumQRCodeErrorCorrectionLevel;
	static EnumRegionPredetectionMode: typeof EnumRegionPredetectionMode;
	static EnumResultCoordinateType: typeof EnumResultCoordinateType;
	static EnumResultType: typeof EnumResultType;
	static EnumScaleUpMode: typeof EnumScaleUpMode;
	static EnumTerminatePhase: typeof EnumTerminatePhase;
	static EnumTextFilterMode: typeof EnumTextFilterMode;
	static EnumTextResultOrderMode: typeof EnumTextResultOrderMode;
	static EnumTextureDetectionMode: typeof EnumTextureDetectionMode;
	/**
	 * Get the current version.
	*/
	static get version(): string;
	static get productKeys(): string;
	/**
	 * Get or set the Dynamsoft Barcode Reader SDK product keys.
	 * ```js
	 * Dynamsoft.DBR.productKeys = "PRODUCT-KEYS";
	 * ```
	 * For convenience, you can set `productKeys` in `script` tag instead.
	 * ```html
	 * <script src="https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.js" data-productKeys="PRODUCT-KEYS"></script>
	 * ```
	 */
	static set productKeys(keys: string);
	static get handshakeCode(): string;
	/**
	 * Get or set the Dynamsoft Barcode Reader SDK handshake code. The `handshakeCode` is an alias of `productKeys`. Specifically refers to the key that requires **network** authentication.
	 * ```js
	 * Dynamsoft.DBR.handshakeCode = "123****-mytest";
	 * ```
	 * For convenience, you can set `handshakeCode` in `script` tag instead.
	 * ```html
	 * <script src="https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.js" data-handshakeCode="123****-mytest"></script>
	 * ```
	 */
	static set handshakeCode(keys: string);
	static get organizationID(): string;
	/**
	 * Use organization ID to get authentication from network. Keep handshakeCode empty if you want to use default `handshake` of the organization.
	 * ```js
	 * Dynamsoft.DBR.organizationID = "123****";
	 * ```
	 * For convenience, you can set `organizationID` in `script` tag instead.
	 * ```html
	 * <script src="https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/dbr.js" data-organizationID="123****"></script>
	 * ```
	 * @see [[handshakeCode]]
	 */
	static set organizationID(keys: string);
	static get sessionPassword(): string;
	/**
	 * Specify a password to protect the `Handshake Code` from abuse.
	 * ```js
	 * Dynamsoft.DBR.handshakeCode = "123****-mytest";
	 * Dynamsoft.DBR.sessionPassword = "@#$%****";
	 * ```
	 * Since js in the browser is plaintext, it is not safe to set a password. It is recommended that you bind the `domain` as `Validation field` in the [handshake settings in dynamsoft website](https://www.dynamsoft.com/lts/index.html#/handshakeCodes) or your self-hosted license server.
	 *
	 * In nodejs, password is meaningful.
	 * @see [[handshakeCode]]
	 */
	static set sessionPassword(keys: string);
	/** @ignore */
	static get browserInfo(): any;
	/**
	 * Detect environment and get a report.
	 * ```js
	 * console.log(Dynamsoft.DBR.detectEnvironment());
	 * // {"wasm":true, "worker":true, "getUserMedia":true, "camera":true, "browser":"Chrome", "version":90, "OS":"Windows"}
	 * ```
	 */
	static detectEnvironment(): Promise<any>;
	/** @ignore */
	static get _workerName(): string;
	/** @ignore */
	static set _workerName(name: string);
	static get engineResourcePath(): string;
	/**
	 * Specify the Barcode Reader SDK engine (WASM) url. The SDK tries to automatically explore the engine location.
	 * If the auto-explored engine location is incorrect, you can manually specify the engine location.
	 * The property needs to be set before [[loadWasm]].
	 * ```js
	 * Dynamsoft.DBR.engineResourcePath = "https://cdn.jsdelivr.net/npm/dynamsoft-javascript-barcode@8.6.1/dist/";
	 * await Dynamsoft.DBR.loadWasm();
	 * ```
	*/
	static set engineResourcePath(value: string);
	static get licenseServer(): string[] | string;
	/**
	 * Specify the license server URL.
	*/
	static set licenseServer(value: string[] | string);
	/** @ignore */
	static get deviceFriendlyName(): string;
	/** @ignore */
	static set deviceFriendlyName(value: string);
	/** @ignore */
	static get _onLog(): (message: any) => void;
	/** @ignore */
	static set _onLog(value: (message: any) => void);
	/** @ignore */
	static get _bWasmDebug(): boolean;
	/** @ignore */
	static set _bWasmDebug(value: boolean);
	/** @ignore */
	static get _bUseFullFeature(): boolean;
	/** @ignore */
	static set _bUseFullFeature(value: boolean);
	/** @ignore */
	static get _dbrWorker(): Worker;
	/** @ignore */
	static isLoaded(): boolean;
	/**
	 * Check if the decoding module is loaded.
	 */
	static isWasmLoaded(): boolean;
	/**
	 * Before most operations, `loadWasm` needs to be excuted firstly.
	 * Most time, you do not need excute `loadWasm` manually. Because when you excute [[createInstance]], `loadWasm` will be excuted implicitly.
	 * Some properties can't be changed after `loadWasm`.
	 * Calling `loadWasm` in advance can avoid the long wait when `createInstance`.
	 * ```js
	 * window.addEventListener('DOMContentLoaded', (event) => {
	 *   DBR.loadWasm();
	 * });
	 * ```
	 */
	static loadWasm(): Promise<void>;
}




declare var Dynamsoft:{
    DBR: typeof DBR;
}
