"use strict"; var readAsync, readBinary, Module = void 0 !== Module ? Module : {}, ENVIRONMENT_IS_WEB = !1, ENVIRONMENT_IS_WORKER = !0, ENVIRONMENT_IS_NODE = !1, moduleOverrides = Object.assign({}, Module), thisProgram = "./this.program", quit_ = (e, r) => { throw r }, scriptDirectory = ""; function locateFile(e) { return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e } (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : "undefined" != typeof document && document.currentScript && (scriptDirectory = document.currentScript.src), scriptDirectory = scriptDirectory.startsWith("blob:") ? "" : scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1), ENVIRONMENT_IS_WORKER && (readBinary = e => { var r = new XMLHttpRequest; return r.open("GET", e, !1), r.responseType = "arraybuffer", r.send(null), new Uint8Array(r.response) }), readAsync = async e => { var r = await fetch(e, { credentials: "same-origin" }); if (r.ok) return r.arrayBuffer(); throw new Error(r.status + " : " + r.url) }); var wasmBinary, wasmMemory, out = Module.print || console.log.bind(console), err = Module.printErr || console.error.bind(console); Object.assign(Module, moduleOverrides), moduleOverrides = null; var EXITSTATUS, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64, ABORT = !1, runtimeInitialized = !1, dataURIPrefix = "data:application/octet-stream;base64,", isDataURI = e => e.startsWith(dataURIPrefix); function updateMemoryViews() { var e = wasmMemory.buffer; Module.HEAP8 = HEAP8 = new Int8Array(e), HEAP16 = new Int16Array(e), Module.HEAPU8 = HEAPU8 = new Uint8Array(e), HEAPU16 = new Uint16Array(e), HEAP32 = new Int32Array(e), HEAPU32 = new Uint32Array(e), HEAPF32 = new Float32Array(e), HEAPF64 = new Float64Array(e), HEAP64 = new BigInt64Array(e), HEAPU64 = new BigUint64Array(e) } var __ATPRERUN__ = [], __ATINIT__ = [], __ATPOSTRUN__ = []; function preRun() { callRuntimeCallbacks(__ATPRERUN__) } function initRuntime() { runtimeInitialized = !0, Module.noFSInit || FS.initialized || FS.init(), FS.ignorePermissions = !1, TTY.init(), SOCKFS.root = FS.mount(SOCKFS, {}, null), callRuntimeCallbacks(__ATINIT__) } function postRun() { callRuntimeCallbacks(__ATPOSTRUN__) } function addOnInit(e) { __ATINIT__.unshift(e) } var wasmBinaryFile, runDependencies = 0, dependenciesFulfilled = null; function getUniqueRunDependency(e) { return e } function addRunDependency(e) { runDependencies++ } function removeRunDependency(e) { if (0 == --runDependencies && dependenciesFulfilled) { var r = dependenciesFulfilled; dependenciesFulfilled = null, r() } } function abort(e) { throw err(e = "Aborted(" + e + ")"), ABORT = !0, e += ". Build with -sASSERTIONS for more info.", new WebAssembly.RuntimeError(e) } function findWasmBinary() { var e = "dynamsoft-barcode-reader-bundle.wasm"; return isDataURI(e) ? e : locateFile(e) } function getBinarySync(e) { if (e == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary); if (readBinary) return readBinary(e); throw "both async and sync fetching of the wasm failed" } async function getWasmBinary(e) { if (!wasmBinary) try { var r = await readAsync(e); return new Uint8Array(r) } catch { } return getBinarySync(e) } async function instantiateArrayBuffer(e, r) { try { var t = await getWasmBinary(e); return await WebAssembly.instantiate(t, r) } catch (e) { err(`failed to asynchronously prepare wasm: ${e}`), abort(e) } } async function instantiateAsync(e, r, t) { if (!e && "function" == typeof WebAssembly.instantiateStreaming && !isDataURI(r)) try { var n = fetch(r, { credentials: "same-origin" }); return await WebAssembly.instantiateStreaming(n, t) } catch (e) { err(`wasm streaming compile failed: ${e}`), err("falling back to ArrayBuffer instantiation") } return instantiateArrayBuffer(r, t) } function getWasmImports() { return { env: wasmImports, wasi_snapshot_preview1: wasmImports } } async function createWasm() { addRunDependency("wasm-instantiate"); var e = getWasmImports(); wasmBinaryFile ??= findWasmBinary(); var r = function (e) { return r = e.instance, wasmExports = r.exports, wasmMemory = wasmExports.memory, updateMemoryViews(), wasmTable = wasmExports.__indirect_function_table, addOnInit(wasmExports.__wasm_call_ctors), exportWasmSymbols(wasmExports), removeRunDependency("wasm-instantiate"), wasmExports; var r }(await instantiateAsync(wasmBinary, wasmBinaryFile, e)); return r } class ExitStatus { name = "ExitStatus"; constructor(e) { this.message = `Program terminated with exit(${e})`, this.status = e } } var wasmTable, callRuntimeCallbacks = e => { for (; e.length > 0;)e.shift()(Module) }, asmjsMangle = e => ("__main_argc_argv" == e && (e = "main"), e.startsWith("dynCall_") ? e : "_" + e), exportWasmSymbols = e => { for (var r in e) { var t = asmjsMangle(r); this[t] = Module[t] = e[r] } }, UTF8Decoder = "undefined" != typeof TextDecoder ? new TextDecoder : void 0, UTF8ArrayToString = (e, r = 0, t = NaN) => { for (var n = r + t, o = r; e[o] && !(o >= n);)++o; if (o - r > 16 && e.buffer && UTF8Decoder) return UTF8Decoder.decode(e.subarray(r, o)); for (var a = ""; r < o;) { var s = e[r++]; if (128 & s) { var i = 63 & e[r++]; if (192 != (224 & s)) { var l = 63 & e[r++]; if ((s = 224 == (240 & s) ? (15 & s) << 12 | i << 6 | l : (7 & s) << 18 | i << 12 | l << 6 | 63 & e[r++]) < 65536) a += String.fromCharCode(s); else { var c = s - 65536; a += String.fromCharCode(55296 | c >> 10, 56320 | 1023 & c) } } else a += String.fromCharCode((31 & s) << 6 | i) } else a += String.fromCharCode(s) } return a }, UTF8ToString = (e, r) => e ? UTF8ArrayToString(HEAPU8, e, r) : "", ___assert_fail = (e, r, t, n) => abort(`Assertion failed: ${UTF8ToString(e)}, at: ` + [r ? UTF8ToString(r) : "unknown filename", t, n ? UTF8ToString(n) : "unknown function"]), getWasmTableEntry = e => wasmTable.get(e), ___call_sighandler = (e, r) => getWasmTableEntry(e)(r); class ExceptionInfo { constructor(e) { this.excPtr = e, this.ptr = e - 24 } set_type(e) { HEAPU32[this.ptr + 4 >> 2] = e } get_type() { return HEAPU32[this.ptr + 4 >> 2] } set_destructor(e) { HEAPU32[this.ptr + 8 >> 2] = e } get_destructor() { return HEAPU32[this.ptr + 8 >> 2] } set_caught(e) { e = e ? 1 : 0, HEAP8[this.ptr + 12] = e } get_caught() { return 0 != HEAP8[this.ptr + 12] } set_rethrown(e) { e = e ? 1 : 0, HEAP8[this.ptr + 13] = e } get_rethrown() { return 0 != HEAP8[this.ptr + 13] } init(e, r) { this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(r) } set_adjusted_ptr(e) { HEAPU32[this.ptr + 16 >> 2] = e } get_adjusted_ptr() { return HEAPU32[this.ptr + 16 >> 2] } } var exceptionLast = 0, uncaughtExceptionCount = 0, ___cxa_throw = (e, r, t) => { throw new ExceptionInfo(e).init(r, t), uncaughtExceptionCount++, exceptionLast = e }, PATH = { isAbs: e => "/" === e.charAt(0), splitPath: e => /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(e).slice(1), normalizeArray: (e, r) => { for (var t = 0, n = e.length - 1; n >= 0; n--) { var o = e[n]; "." === o ? e.splice(n, 1) : ".." === o ? (e.splice(n, 1), t++) : t && (e.splice(n, 1), t--) } if (r) for (; t; t--)e.unshift(".."); return e }, normalize: e => { var r = PATH.isAbs(e), t = "/" === e.slice(-1); return (e = PATH.normalizeArray(e.split("/").filter((e => !!e)), !r).join("/")) || r || (e = "."), e && t && (e += "/"), (r ? "/" : "") + e }, dirname: e => { var r = PATH.splitPath(e), t = r[0], n = r[1]; return t || n ? (n && (n = n.slice(0, -1)), t + n) : "." }, basename: e => e && e.match(/([^\/]+|\/)\/*$/)[1], join: (...e) => PATH.normalize(e.join("/")), join2: (e, r) => PATH.normalize(e + "/" + r) }, initRandomFill = () => e => crypto.getRandomValues(e), randomFill = e => { (randomFill = initRandomFill())(e) }, PATH_FS = { resolve: (...e) => { for (var r = "", t = !1, n = e.length - 1; n >= -1 && !t; n--) { var o = n >= 0 ? e[n] : FS.cwd(); if ("string" != typeof o) throw new TypeError("Arguments to path.resolve must be strings"); if (!o) return ""; r = o + "/" + r, t = PATH.isAbs(o) } return (t ? "/" : "") + (r = PATH.normalizeArray(r.split("/").filter((e => !!e)), !t).join("/")) || "." }, relative: (e, r) => { function t(e) { for (var r = 0; r < e.length && "" === e[r]; r++); for (var t = e.length - 1; t >= 0 && "" === e[t]; t--); return r > t ? [] : e.slice(r, t - r + 1) } e = PATH_FS.resolve(e).slice(1), r = PATH_FS.resolve(r).slice(1); for (var n = t(e.split("/")), o = t(r.split("/")), a = Math.min(n.length, o.length), s = a, i = 0; i < a; i++)if (n[i] !== o[i]) { s = i; break } var l = []; for (i = s; i < n.length; i++)l.push(".."); return (l = l.concat(o.slice(s))).join("/") } }, FS_stdin_getChar_buffer = [], lengthBytesUTF8 = e => { for (var r = 0, t = 0; t < e.length; ++t) { var n = e.charCodeAt(t); n <= 127 ? r++ : n <= 2047 ? r += 2 : n >= 55296 && n <= 57343 ? (r += 4, ++t) : r += 3 } return r }, stringToUTF8Array = (e, r, t, n) => { if (!(n > 0)) return 0; for (var o = t, a = t + n - 1, s = 0; s < e.length; ++s) { var i = e.charCodeAt(s); if (i >= 55296 && i <= 57343) i = 65536 + ((1023 & i) << 10) | 1023 & e.charCodeAt(++s); if (i <= 127) { if (t >= a) break; r[t++] = i } else if (i <= 2047) { if (t + 1 >= a) break; r[t++] = 192 | i >> 6, r[t++] = 128 | 63 & i } else if (i <= 65535) { if (t + 2 >= a) break; r[t++] = 224 | i >> 12, r[t++] = 128 | i >> 6 & 63, r[t++] = 128 | 63 & i } else { if (t + 3 >= a) break; r[t++] = 240 | i >> 18, r[t++] = 128 | i >> 12 & 63, r[t++] = 128 | i >> 6 & 63, r[t++] = 128 | 63 & i } } return r[t] = 0, t - o }, intArrayFromString = (e, r, t) => { var n = t > 0 ? t : lengthBytesUTF8(e) + 1, o = new Array(n), a = stringToUTF8Array(e, o, 0, o.length); return r && (o.length = a), o }, FS_stdin_getChar = () => { if (!FS_stdin_getChar_buffer.length) { return null } return FS_stdin_getChar_buffer.shift() }, TTY = { ttys: [], init() { }, shutdown() { }, register(e, r) { TTY.ttys[e] = { input: [], output: [], ops: r }, FS.registerDevice(e, TTY.stream_ops) }, stream_ops: { open(e) { var r = TTY.ttys[e.node.rdev]; if (!r) throw new FS.ErrnoError(43); e.tty = r, e.seekable = !1 }, close(e) { e.tty.ops.fsync(e.tty) }, fsync(e) { e.tty.ops.fsync(e.tty) }, read(e, r, t, n, o) { if (!e.tty || !e.tty.ops.get_char) throw new FS.ErrnoError(60); for (var a = 0, s = 0; s < n; s++) { var i; try { i = e.tty.ops.get_char(e.tty) } catch (e) { throw new FS.ErrnoError(29) } if (void 0 === i && 0 === a) throw new FS.ErrnoError(6); if (null == i) break; a++, r[t + s] = i } return a && (e.node.atime = Date.now()), a }, write(e, r, t, n, o) { if (!e.tty || !e.tty.ops.put_char) throw new FS.ErrnoError(60); try { for (var a = 0; a < n; a++)e.tty.ops.put_char(e.tty, r[t + a]) } catch (e) { throw new FS.ErrnoError(29) } return n && (e.node.mtime = e.node.ctime = Date.now()), a } }, default_tty_ops: { get_char: e => FS_stdin_getChar(), put_char(e, r) { null === r || 10 === r ? (out(UTF8ArrayToString(e.output)), e.output = []) : 0 != r && e.output.push(r) }, fsync(e) { e.output?.length > 0 && (out(UTF8ArrayToString(e.output)), e.output = []) }, ioctl_tcgets: e => ({ c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }), ioctl_tcsets: (e, r, t) => 0, ioctl_tiocgwinsz: e => [24, 80] }, default_tty1_ops: { put_char(e, r) { null === r || 10 === r ? (err(UTF8ArrayToString(e.output)), e.output = []) : 0 != r && e.output.push(r) }, fsync(e) { e.output?.length > 0 && (err(UTF8ArrayToString(e.output)), e.output = []) } } }, alignMemory = (e, r) => Math.ceil(e / r) * r, mmapAlloc = e => { abort() }, MEMFS = { ops_table: null, mount: e => MEMFS.createNode(null, "/", 16895, 0), createNode(e, r, t, n) { if (FS.isBlkdev(t) || FS.isFIFO(t)) throw new FS.ErrnoError(63); MEMFS.ops_table ||= { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } }; var o = FS.createNode(e, r, t, n); return FS.isDir(o.mode) ? (o.node_ops = MEMFS.ops_table.dir.node, o.stream_ops = MEMFS.ops_table.dir.stream, o.contents = {}) : FS.isFile(o.mode) ? (o.node_ops = MEMFS.ops_table.file.node, o.stream_ops = MEMFS.ops_table.file.stream, o.usedBytes = 0, o.contents = null) : FS.isLink(o.mode) ? (o.node_ops = MEMFS.ops_table.link.node, o.stream_ops = MEMFS.ops_table.link.stream) : FS.isChrdev(o.mode) && (o.node_ops = MEMFS.ops_table.chrdev.node, o.stream_ops = MEMFS.ops_table.chrdev.stream), o.atime = o.mtime = o.ctime = Date.now(), e && (e.contents[r] = o, e.atime = e.mtime = e.ctime = o.atime), o }, getFileDataAsTypedArray: e => e.contents ? e.contents.subarray ? e.contents.subarray(0, e.usedBytes) : new Uint8Array(e.contents) : new Uint8Array(0), expandFileStorage(e, r) { var t = e.contents ? e.contents.length : 0; if (!(t >= r)) { r = Math.max(r, t * (t < 1048576 ? 2 : 1.125) >>> 0), 0 != t && (r = Math.max(r, 256)); var n = e.contents; e.contents = new Uint8Array(r), e.usedBytes > 0 && e.contents.set(n.subarray(0, e.usedBytes), 0) } }, resizeFileStorage(e, r) { if (e.usedBytes != r) if (0 == r) e.contents = null, e.usedBytes = 0; else { var t = e.contents; e.contents = new Uint8Array(r), t && e.contents.set(t.subarray(0, Math.min(r, e.usedBytes))), e.usedBytes = r } }, node_ops: { getattr(e) { var r = {}; return r.dev = FS.isChrdev(e.mode) ? e.id : 1, r.ino = e.id, r.mode = e.mode, r.nlink = 1, r.uid = 0, r.gid = 0, r.rdev = e.rdev, FS.isDir(e.mode) ? r.size = 4096 : FS.isFile(e.mode) ? r.size = e.usedBytes : FS.isLink(e.mode) ? r.size = e.link.length : r.size = 0, r.atime = new Date(e.atime), r.mtime = new Date(e.mtime), r.ctime = new Date(e.ctime), r.blksize = 4096, r.blocks = Math.ceil(r.size / r.blksize), r }, setattr(e, r) { for (const t of ["mode", "atime", "mtime", "ctime"]) null != r[t] && (e[t] = r[t]); void 0 !== r.size && MEMFS.resizeFileStorage(e, r.size) }, lookup(e, r) { throw MEMFS.doesNotExistError }, mknod: (e, r, t, n) => MEMFS.createNode(e, r, t, n), rename(e, r, t) { var n; try { n = FS.lookupNode(r, t) } catch (e) { } if (n) { if (FS.isDir(e.mode)) for (var o in n.contents) throw new FS.ErrnoError(55); FS.hashRemoveNode(n) } delete e.parent.contents[e.name], r.contents[t] = e, e.name = t, r.ctime = r.mtime = e.parent.ctime = e.parent.mtime = Date.now() }, unlink(e, r) { delete e.contents[r], e.ctime = e.mtime = Date.now() }, rmdir(e, r) { var t = FS.lookupNode(e, r); for (var n in t.contents) throw new FS.ErrnoError(55); delete e.contents[r], e.ctime = e.mtime = Date.now() }, readdir: e => [".", "..", ...Object.keys(e.contents)], symlink(e, r, t) { var n = MEMFS.createNode(e, r, 41471, 0); return n.link = t, n }, readlink(e) { if (!FS.isLink(e.mode)) throw new FS.ErrnoError(28); return e.link } }, stream_ops: { read(e, r, t, n, o) { var a = e.node.contents; if (o >= e.node.usedBytes) return 0; var s = Math.min(e.node.usedBytes - o, n); if (s > 8 && a.subarray) r.set(a.subarray(o, o + s), t); else for (var i = 0; i < s; i++)r[t + i] = a[o + i]; return s }, write(e, r, t, n, o, a) { if (r.buffer === HEAP8.buffer && (a = !1), !n) return 0; var s = e.node; if (s.mtime = s.ctime = Date.now(), r.subarray && (!s.contents || s.contents.subarray)) { if (a) return s.contents = r.subarray(t, t + n), s.usedBytes = n, n; if (0 === s.usedBytes && 0 === o) return s.contents = r.slice(t, t + n), s.usedBytes = n, n; if (o + n <= s.usedBytes) return s.contents.set(r.subarray(t, t + n), o), n } if (MEMFS.expandFileStorage(s, o + n), s.contents.subarray && r.subarray) s.contents.set(r.subarray(t, t + n), o); else for (var i = 0; i < n; i++)s.contents[o + i] = r[t + i]; return s.usedBytes = Math.max(s.usedBytes, o + n), n }, llseek(e, r, t) { var n = r; if (1 === t ? n += e.position : 2 === t && FS.isFile(e.node.mode) && (n += e.node.usedBytes), n < 0) throw new FS.ErrnoError(28); return n }, allocate(e, r, t) { MEMFS.expandFileStorage(e.node, r + t), e.node.usedBytes = Math.max(e.node.usedBytes, r + t) }, mmap(e, r, t, n, o) { if (!FS.isFile(e.node.mode)) throw new FS.ErrnoError(43); var a, s, i = e.node.contents; if (2 & o || !i || i.buffer !== HEAP8.buffer) { if (s = !0, !(a = mmapAlloc(r))) throw new FS.ErrnoError(48); i && ((t > 0 || t + r < i.length) && (i = i.subarray ? i.subarray(t, t + r) : Array.prototype.slice.call(i, t, t + r)), HEAP8.set(i, a)) } else s = !1, a = i.byteOffset; return { ptr: a, allocated: s } }, msync: (e, r, t, n, o) => (MEMFS.stream_ops.write(e, r, 0, n, t, !1), 0) } }, asyncLoad = async e => { var r = await readAsync(e); return new Uint8Array(r) }, FS_createDataFile = (e, r, t, n, o, a) => { FS.createDataFile(e, r, t, n, o, a) }, preloadPlugins = [], FS_handledByPreloadPlugin = (e, r, t, n) => { "undefined" != typeof Browser && Browser.init(); var o = !1; return preloadPlugins.forEach((a => { o || a.canHandle(r) && (a.handle(e, r, t, n), o = !0) })), o }, FS_createPreloadedFile = (e, r, t, n, o, a, s, i, l, c) => { var d = r ? PATH_FS.resolve(PATH.join2(e, r)) : e, u = getUniqueRunDependency(`cp ${d}`); function m(t) { function m(t) { c?.(), i || FS_createDataFile(e, r, t, n, o, l), a?.(), removeRunDependency(u) } FS_handledByPreloadPlugin(t, d, m, (() => { s?.(), removeRunDependency(u) })) || m(t) } addRunDependency(u), "string" == typeof t ? asyncLoad(t).then(m, s) : m(t) }, FS_modeStringToFlags = e => { var r = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[e]; if (void 0 === r) throw new Error(`Unknown file open mode: ${e}`); return r }, FS_getMode = (e, r) => { var t = 0; return e && (t |= 365), r && (t |= 146), t }, FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: !1, ignorePermissions: !0, ErrnoError: class { name = "ErrnoError"; constructor(e) { this.errno = e } }, filesystems: null, syncFSRequests: 0, FSStream: class { shared = {}; get object() { return this.node } set object(e) { this.node = e } get isRead() { return 1 != (2097155 & this.flags) } get isWrite() { return !!(2097155 & this.flags) } get isAppend() { return 1024 & this.flags } get flags() { return this.shared.flags } set flags(e) { this.shared.flags = e } get position() { return this.shared.position } set position(e) { this.shared.position = e } }, FSNode: class { node_ops = {}; stream_ops = {}; readMode = 365; writeMode = 146; mounted = null; constructor(e, r, t, n) { e || (e = this), this.parent = e, this.mount = e.mount, this.id = FS.nextInode++, this.name = r, this.mode = t, this.rdev = n, this.atime = this.mtime = this.ctime = Date.now() } get read() { return (this.mode & this.readMode) === this.readMode } set read(e) { e ? this.mode |= this.readMode : this.mode &= ~this.readMode } get write() { return (this.mode & this.writeMode) === this.writeMode } set write(e) { e ? this.mode |= this.writeMode : this.mode &= ~this.writeMode } get isFolder() { return FS.isDir(this.mode) } get isDevice() { return FS.isChrdev(this.mode) } }, lookupPath(e, r = {}) { if (!e) throw new FS.ErrnoError(44); r.follow_mount ??= !0, PATH.isAbs(e) || (e = FS.cwd() + "/" + e); e: for (var t = 0; t < 40; t++) { for (var n = e.split("/").filter((e => !!e)), o = FS.root, a = "/", s = 0; s < n.length; s++) { var i = s === n.length - 1; if (i && r.parent) break; if ("." !== n[s]) if (".." !== n[s]) { a = PATH.join2(a, n[s]); try { o = FS.lookupNode(o, n[s]) } catch (e) { if (44 === e?.errno && i && r.noent_okay) return { path: a }; throw e } if (!FS.isMountpoint(o) || i && !r.follow_mount || (o = o.mounted.root), FS.isLink(o.mode) && (!i || r.follow)) { if (!o.node_ops.readlink) throw new FS.ErrnoError(52); var l = o.node_ops.readlink(o); PATH.isAbs(l) || (l = PATH.dirname(a) + "/" + l), e = l + "/" + n.slice(s + 1).join("/"); continue e } } else a = PATH.dirname(a), o = o.parent } return { path: a, node: o } } throw new FS.ErrnoError(32) }, getPath(e) { for (var r; ;) { if (FS.isRoot(e)) { var t = e.mount.mountpoint; return r ? "/" !== t[t.length - 1] ? `${t}/${r}` : t + r : t } r = r ? `${e.name}/${r}` : e.name, e = e.parent } }, hashName(e, r) { for (var t = 0, n = 0; n < r.length; n++)t = (t << 5) - t + r.charCodeAt(n) | 0; return (e + t >>> 0) % FS.nameTable.length }, hashAddNode(e) { var r = FS.hashName(e.parent.id, e.name); e.name_next = FS.nameTable[r], FS.nameTable[r] = e }, hashRemoveNode(e) { var r = FS.hashName(e.parent.id, e.name); if (FS.nameTable[r] === e) FS.nameTable[r] = e.name_next; else for (var t = FS.nameTable[r]; t;) { if (t.name_next === e) { t.name_next = e.name_next; break } t = t.name_next } }, lookupNode(e, r) { var t = FS.mayLookup(e); if (t) throw new FS.ErrnoError(t); for (var n = FS.hashName(e.id, r), o = FS.nameTable[n]; o; o = o.name_next) { var a = o.name; if (o.parent.id === e.id && a === r) return o } return FS.lookup(e, r) }, createNode(e, r, t, n) { var o = new FS.FSNode(e, r, t, n); return FS.hashAddNode(o), o }, destroyNode(e) { FS.hashRemoveNode(e) }, isRoot: e => e === e.parent, isMountpoint: e => !!e.mounted, isFile: e => 32768 == (61440 & e), isDir: e => 16384 == (61440 & e), isLink: e => 40960 == (61440 & e), isChrdev: e => 8192 == (61440 & e), isBlkdev: e => 24576 == (61440 & e), isFIFO: e => 4096 == (61440 & e), isSocket: e => !(49152 & ~e), flagsToPermissionString(e) { var r = ["r", "w", "rw"][3 & e]; return 512 & e && (r += "w"), r }, nodePermissions: (e, r) => FS.ignorePermissions || (!r.includes("r") || 292 & e.mode) && (!r.includes("w") || 146 & e.mode) && (!r.includes("x") || 73 & e.mode) ? 0 : 2, mayLookup(e) { if (!FS.isDir(e.mode)) return 54; var r = FS.nodePermissions(e, "x"); return r || (e.node_ops.lookup ? 0 : 2) }, mayCreate(e, r) { if (!FS.isDir(e.mode)) return 54; try { FS.lookupNode(e, r); return 20 } catch (e) { } return FS.nodePermissions(e, "wx") }, mayDelete(e, r, t) { var n; try { n = FS.lookupNode(e, r) } catch (e) { return e.errno } var o = FS.nodePermissions(e, "wx"); if (o) return o; if (t) { if (!FS.isDir(n.mode)) return 54; if (FS.isRoot(n) || FS.getPath(n) === FS.cwd()) return 10 } else if (FS.isDir(n.mode)) return 31; return 0 }, mayOpen: (e, r) => e ? FS.isLink(e.mode) ? 32 : FS.isDir(e.mode) && ("r" !== FS.flagsToPermissionString(r) || 576 & r) ? 31 : FS.nodePermissions(e, FS.flagsToPermissionString(r)) : 44, checkOpExists(e, r) { if (!e) throw new FS.ErrnoError(r); return e }, MAX_OPEN_FDS: 4096, nextfd() { for (var e = 0; e <= FS.MAX_OPEN_FDS; e++)if (!FS.streams[e]) return e; throw new FS.ErrnoError(33) }, getStreamChecked(e) { var r = FS.getStream(e); if (!r) throw new FS.ErrnoError(8); return r }, getStream: e => FS.streams[e], createStream: (e, r = -1) => (e = Object.assign(new FS.FSStream, e), -1 == r && (r = FS.nextfd()), e.fd = r, FS.streams[r] = e, e), closeStream(e) { FS.streams[e] = null }, dupStream(e, r = -1) { var t = FS.createStream(e, r); return t.stream_ops?.dup?.(t), t }, doSetAttr(e, r, t) { var n = e?.stream_ops.setattr, o = n ? e : r; n ??= r.node_ops.setattr, FS.checkOpExists(n, 63), n(o, t) }, chrdev_stream_ops: { open(e) { var r = FS.getDevice(e.node.rdev); e.stream_ops = r.stream_ops, e.stream_ops.open?.(e) }, llseek() { throw new FS.ErrnoError(70) } }, major: e => e >> 8, minor: e => 255 & e, makedev: (e, r) => e << 8 | r, registerDevice(e, r) { FS.devices[e] = { stream_ops: r } }, getDevice: e => FS.devices[e], getMounts(e) { for (var r = [], t = [e]; t.length;) { var n = t.pop(); r.push(n), t.push(...n.mounts) } return r }, syncfs(e, r) { "function" == typeof e && (r = e, e = !1), FS.syncFSRequests++, FS.syncFSRequests > 1 && err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`); var t = FS.getMounts(FS.root.mount), n = 0; function o(e) { return FS.syncFSRequests--, r(e) } function a(e) { if (e) return a.errored ? void 0 : (a.errored = !0, o(e)); ++n >= t.length && o(null) } t.forEach((r => { if (!r.type.syncfs) return a(null); r.type.syncfs(r, e, a) })) }, mount(e, r, t) { var n, o = "/" === t, a = !t; if (o && FS.root) throw new FS.ErrnoError(10); if (!o && !a) { var s = FS.lookupPath(t, { follow_mount: !1 }); if (t = s.path, n = s.node, FS.isMountpoint(n)) throw new FS.ErrnoError(10); if (!FS.isDir(n.mode)) throw new FS.ErrnoError(54) } var i = { type: e, opts: r, mountpoint: t, mounts: [] }, l = e.mount(i); return l.mount = i, i.root = l, o ? FS.root = l : n && (n.mounted = i, n.mount && n.mount.mounts.push(i)), l }, unmount(e) { var r = FS.lookupPath(e, { follow_mount: !1 }); if (!FS.isMountpoint(r.node)) throw new FS.ErrnoError(28); var t = r.node, n = t.mounted, o = FS.getMounts(n); Object.keys(FS.nameTable).forEach((e => { for (var r = FS.nameTable[e]; r;) { var t = r.name_next; o.includes(r.mount) && FS.destroyNode(r), r = t } })), t.mounted = null; var a = t.mount.mounts.indexOf(n); t.mount.mounts.splice(a, 1) }, lookup: (e, r) => e.node_ops.lookup(e, r), mknod(e, r, t) { var n = FS.lookupPath(e, { parent: !0 }).node, o = PATH.basename(e); if (!o) throw new FS.ErrnoError(28); if ("." === o || ".." === o) throw new FS.ErrnoError(20); var a = FS.mayCreate(n, o); if (a) throw new FS.ErrnoError(a); if (!n.node_ops.mknod) throw new FS.ErrnoError(63); return n.node_ops.mknod(n, o, r, t) }, statfs: e => FS.statfsNode(FS.lookupPath(e, { follow: !0 }).node), statfsStream: e => FS.statfsNode(e.node), statfsNode(e) { var r = { bsize: 4096, frsize: 4096, blocks: 1e6, bfree: 5e5, bavail: 5e5, files: FS.nextInode, ffree: FS.nextInode - 1, fsid: 42, flags: 2, namelen: 255 }; return e.node_ops.statfs && Object.assign(r, e.node_ops.statfs(e.mount.opts.root)), r }, create: (e, r = 438) => (r &= 4095, r |= 32768, FS.mknod(e, r, 0)), mkdir: (e, r = 511) => (r &= 1023, r |= 16384, FS.mknod(e, r, 0)), mkdirTree(e, r) { for (var t = e.split("/"), n = "", o = 0; o < t.length; ++o)if (t[o]) { n += "/" + t[o]; try { FS.mkdir(n, r) } catch (e) { if (20 != e.errno) throw e } } }, mkdev: (e, r, t) => (void 0 === t && (t = r, r = 438), r |= 8192, FS.mknod(e, r, t)), symlink(e, r) { if (!PATH_FS.resolve(e)) throw new FS.ErrnoError(44); var t = FS.lookupPath(r, { parent: !0 }).node; if (!t) throw new FS.ErrnoError(44); var n = PATH.basename(r), o = FS.mayCreate(t, n); if (o) throw new FS.ErrnoError(o); if (!t.node_ops.symlink) throw new FS.ErrnoError(63); return t.node_ops.symlink(t, n, e) }, rename(e, r) { var t, n, o = PATH.dirname(e), a = PATH.dirname(r), s = PATH.basename(e), i = PATH.basename(r); if (t = FS.lookupPath(e, { parent: !0 }).node, n = FS.lookupPath(r, { parent: !0 }).node, !t || !n) throw new FS.ErrnoError(44); if (t.mount !== n.mount) throw new FS.ErrnoError(75); var l, c = FS.lookupNode(t, s), d = PATH_FS.relative(e, a); if ("." !== d.charAt(0)) throw new FS.ErrnoError(28); if ("." !== (d = PATH_FS.relative(r, o)).charAt(0)) throw new FS.ErrnoError(55); try { l = FS.lookupNode(n, i) } catch (e) { } if (c !== l) { var u = FS.isDir(c.mode), m = FS.mayDelete(t, s, u); if (m) throw new FS.ErrnoError(m); if (m = l ? FS.mayDelete(n, i, u) : FS.mayCreate(n, i)) throw new FS.ErrnoError(m); if (!t.node_ops.rename) throw new FS.ErrnoError(63); if (FS.isMountpoint(c) || l && FS.isMountpoint(l)) throw new FS.ErrnoError(10); if (n !== t && (m = FS.nodePermissions(t, "w"))) throw new FS.ErrnoError(m); FS.hashRemoveNode(c); try { t.node_ops.rename(c, n, i), c.parent = n } catch (e) { throw e } finally { FS.hashAddNode(c) } } }, rmdir(e) { var r = FS.lookupPath(e, { parent: !0 }).node, t = PATH.basename(e), n = FS.lookupNode(r, t), o = FS.mayDelete(r, t, !0); if (o) throw new FS.ErrnoError(o); if (!r.node_ops.rmdir) throw new FS.ErrnoError(63); if (FS.isMountpoint(n)) throw new FS.ErrnoError(10); r.node_ops.rmdir(r, t), FS.destroyNode(n) }, readdir(e) { var r = FS.lookupPath(e, { follow: !0 }).node; return FS.checkOpExists(r.node_ops.readdir, 54)(r) }, unlink(e) { var r = FS.lookupPath(e, { parent: !0 }).node; if (!r) throw new FS.ErrnoError(44); var t = PATH.basename(e), n = FS.lookupNode(r, t), o = FS.mayDelete(r, t, !1); if (o) throw new FS.ErrnoError(o); if (!r.node_ops.unlink) throw new FS.ErrnoError(63); if (FS.isMountpoint(n)) throw new FS.ErrnoError(10); r.node_ops.unlink(r, t), FS.destroyNode(n) }, readlink(e) { var r = FS.lookupPath(e).node; if (!r) throw new FS.ErrnoError(44); if (!r.node_ops.readlink) throw new FS.ErrnoError(28); return r.node_ops.readlink(r) }, stat(e, r) { var t = FS.lookupPath(e, { follow: !r }).node; return FS.checkOpExists(t.node_ops.getattr, 63)(t) }, fstat(e) { var r = FS.getStreamChecked(e), t = r.node, n = r.stream_ops.getattr, o = n ? r : t; return n ??= t.node_ops.getattr, FS.checkOpExists(n, 63), n(o) }, lstat: e => FS.stat(e, !0), doChmod(e, r, t, n) { FS.doSetAttr(e, r, { mode: 4095 & t | -4096 & r.mode, ctime: Date.now(), dontFollow: n }) }, chmod(e, r, t) { var n; "string" == typeof e ? n = FS.lookupPath(e, { follow: !t }).node : n = e; FS.doChmod(null, n, r, t) }, lchmod(e, r) { FS.chmod(e, r, !0) }, fchmod(e, r) { var t = FS.getStreamChecked(e); FS.doChmod(t, t.node, r, !1) }, doChown(e, r, t) { FS.doSetAttr(e, r, { timestamp: Date.now(), dontFollow: t }) }, chown(e, r, t, n) { var o; "string" == typeof e ? o = FS.lookupPath(e, { follow: !n }).node : o = e; FS.doChown(null, o, n) }, lchown(e, r, t) { FS.chown(e, r, t, !0) }, fchown(e, r, t) { var n = FS.getStreamChecked(e); FS.doChown(n, n.node, !1) }, doTruncate(e, r, t) { if (FS.isDir(r.mode)) throw new FS.ErrnoError(31); if (!FS.isFile(r.mode)) throw new FS.ErrnoError(28); var n = FS.nodePermissions(r, "w"); if (n) throw new FS.ErrnoError(n); FS.doSetAttr(e, r, { size: t, timestamp: Date.now() }) }, truncate(e, r) { if (r < 0) throw new FS.ErrnoError(28); var t; "string" == typeof e ? t = FS.lookupPath(e, { follow: !0 }).node : t = e; FS.doTruncate(null, t, r) }, ftruncate(e, r) { var t = FS.getStreamChecked(e); if (r < 0 || !(2097155 & t.flags)) throw new FS.ErrnoError(28); FS.doTruncate(t, t.node, r) }, utime(e, r, t) { var n = FS.lookupPath(e, { follow: !0 }).node; FS.checkOpExists(n.node_ops.setattr, 63)(n, { atime: r, mtime: t }) }, open(e, r, t = 438) { if ("" === e) throw new FS.ErrnoError(44); var n, o; if (t = 64 & (r = "string" == typeof r ? FS_modeStringToFlags(r) : r) ? 4095 & t | 32768 : 0, "object" == typeof e) n = e; else { o = e.endsWith("/"); var a = FS.lookupPath(e, { follow: !(131072 & r), noent_okay: !0 }); n = a.node, e = a.path } var s = !1; if (64 & r) if (n) { if (128 & r) throw new FS.ErrnoError(20) } else { if (o) throw new FS.ErrnoError(31); n = FS.mknod(e, 511 | t, 0), s = !0 } if (!n) throw new FS.ErrnoError(44); if (FS.isChrdev(n.mode) && (r &= -513), 65536 & r && !FS.isDir(n.mode)) throw new FS.ErrnoError(54); if (!s) { var i = FS.mayOpen(n, r); if (i) throw new FS.ErrnoError(i) } 512 & r && !s && FS.truncate(n, 0), r &= -131713; var l = FS.createStream({ node: n, path: FS.getPath(n), flags: r, seekable: !0, position: 0, stream_ops: n.stream_ops, ungotten: [], error: !1 }); return l.stream_ops.open && l.stream_ops.open(l), s && FS.chmod(n, 511 & t), l }, close(e) { if (FS.isClosed(e)) throw new FS.ErrnoError(8); e.getdents && (e.getdents = null); try { e.stream_ops.close && e.stream_ops.close(e) } catch (e) { throw e } finally { FS.closeStream(e.fd) } e.fd = null }, isClosed: e => null === e.fd, llseek(e, r, t) { if (FS.isClosed(e)) throw new FS.ErrnoError(8); if (!e.seekable || !e.stream_ops.llseek) throw new FS.ErrnoError(70); if (0 != t && 1 != t && 2 != t) throw new FS.ErrnoError(28); return e.position = e.stream_ops.llseek(e, r, t), e.ungotten = [], e.position }, read(e, r, t, n, o) { if (n < 0 || o < 0) throw new FS.ErrnoError(28); if (FS.isClosed(e)) throw new FS.ErrnoError(8); if (1 == (2097155 & e.flags)) throw new FS.ErrnoError(8); if (FS.isDir(e.node.mode)) throw new FS.ErrnoError(31); if (!e.stream_ops.read) throw new FS.ErrnoError(28); var a = void 0 !== o; if (a) { if (!e.seekable) throw new FS.ErrnoError(70) } else o = e.position; var s = e.stream_ops.read(e, r, t, n, o); return a || (e.position += s), s }, write(e, r, t, n, o, a) { if (n < 0 || o < 0) throw new FS.ErrnoError(28); if (FS.isClosed(e)) throw new FS.ErrnoError(8); if (!(2097155 & e.flags)) throw new FS.ErrnoError(8); if (FS.isDir(e.node.mode)) throw new FS.ErrnoError(31); if (!e.stream_ops.write) throw new FS.ErrnoError(28); e.seekable && 1024 & e.flags && FS.llseek(e, 0, 2); var s = void 0 !== o; if (s) { if (!e.seekable) throw new FS.ErrnoError(70) } else o = e.position; var i = e.stream_ops.write(e, r, t, n, o, a); return s || (e.position += i), i }, allocate(e, r, t) { if (FS.isClosed(e)) throw new FS.ErrnoError(8); if (r < 0 || t <= 0) throw new FS.ErrnoError(28); if (!(2097155 & e.flags)) throw new FS.ErrnoError(8); if (!FS.isFile(e.node.mode) && !FS.isDir(e.node.mode)) throw new FS.ErrnoError(43); if (!e.stream_ops.allocate) throw new FS.ErrnoError(138); e.stream_ops.allocate(e, r, t) }, mmap(e, r, t, n, o) { if (2 & n && !(2 & o) && 2 != (2097155 & e.flags)) throw new FS.ErrnoError(2); if (1 == (2097155 & e.flags)) throw new FS.ErrnoError(2); if (!e.stream_ops.mmap) throw new FS.ErrnoError(43); if (!r) throw new FS.ErrnoError(28); return e.stream_ops.mmap(e, r, t, n, o) }, msync: (e, r, t, n, o) => e.stream_ops.msync ? e.stream_ops.msync(e, r, t, n, o) : 0, ioctl(e, r, t) { if (!e.stream_ops.ioctl) throw new FS.ErrnoError(59); return e.stream_ops.ioctl(e, r, t) }, readFile(e, r = {}) { if (r.flags = r.flags || 0, r.encoding = r.encoding || "binary", "utf8" !== r.encoding && "binary" !== r.encoding) throw new Error(`Invalid encoding type "${r.encoding}"`); var t, n = FS.open(e, r.flags), o = FS.stat(e).size, a = new Uint8Array(o); return FS.read(n, a, 0, o, 0), "utf8" === r.encoding ? t = UTF8ArrayToString(a) : "binary" === r.encoding && (t = a), FS.close(n), t }, writeFile(e, r, t = {}) { t.flags = t.flags || 577; var n = FS.open(e, t.flags, t.mode); if ("string" == typeof r) { var o = new Uint8Array(lengthBytesUTF8(r) + 1), a = stringToUTF8Array(r, o, 0, o.length); FS.write(n, o, 0, a, void 0, t.canOwn) } else { if (!ArrayBuffer.isView(r)) throw new Error("Unsupported data type"); FS.write(n, r, 0, r.byteLength, void 0, t.canOwn) } FS.close(n) }, cwd: () => FS.currentPath, chdir(e) { var r = FS.lookupPath(e, { follow: !0 }); if (null === r.node) throw new FS.ErrnoError(44); if (!FS.isDir(r.node.mode)) throw new FS.ErrnoError(54); var t = FS.nodePermissions(r.node, "x"); if (t) throw new FS.ErrnoError(t); FS.currentPath = r.path }, createDefaultDirectories() { FS.mkdir("/tmp"), FS.mkdir("/home"), FS.mkdir("/home/web_user") }, createDefaultDevices() { FS.mkdir("/dev"), FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (e, r, t, n, o) => n, llseek: () => 0 }), FS.mkdev("/dev/null", FS.makedev(1, 3)), TTY.register(FS.makedev(5, 0), TTY.default_tty_ops), TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops), FS.mkdev("/dev/tty", FS.makedev(5, 0)), FS.mkdev("/dev/tty1", FS.makedev(6, 0)); var e = new Uint8Array(1024), r = 0, t = () => (0 === r && (randomFill(e), r = e.byteLength), e[--r]); FS.createDevice("/dev", "random", t), FS.createDevice("/dev", "urandom", t), FS.mkdir("/dev/shm"), FS.mkdir("/dev/shm/tmp") }, createSpecialDirectories() { FS.mkdir("/proc"); var e = FS.mkdir("/proc/self"); FS.mkdir("/proc/self/fd"), FS.mount({ mount() { var r = FS.createNode(e, "fd", 16895, 73); return r.stream_ops = { llseek: MEMFS.stream_ops.llseek }, r.node_ops = { lookup(e, r) { var t = +r, n = FS.getStreamChecked(t), o = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => n.path }, id: t + 1 }; return o.parent = o, o }, readdir: () => Array.from(FS.streams.entries()).filter((([e, r]) => r)).map((([e, r]) => e.toString())) }, r } }, {}, "/proc/self/fd") }, createStandardStreams(e, r, t) { e ? FS.createDevice("/dev", "stdin", e) : FS.symlink("/dev/tty", "/dev/stdin"), r ? FS.createDevice("/dev", "stdout", null, r) : FS.symlink("/dev/tty", "/dev/stdout"), t ? FS.createDevice("/dev", "stderr", null, t) : FS.symlink("/dev/tty1", "/dev/stderr"); FS.open("/dev/stdin", 0), FS.open("/dev/stdout", 1), FS.open("/dev/stderr", 1) }, staticInit() { FS.nameTable = new Array(4096), FS.mount(MEMFS, {}, "/"), FS.createDefaultDirectories(), FS.createDefaultDevices(), FS.createSpecialDirectories(), FS.filesystems = { MEMFS: MEMFS } }, init(e, r, t) { FS.initialized = !0, FS.createStandardStreams(e, r, t) }, quit() { FS.initialized = !1; for (var e = 0; e < FS.streams.length; e++) { var r = FS.streams[e]; r && FS.close(r) } }, findObject(e, r) { var t = FS.analyzePath(e, r); return t.exists ? t.object : null }, analyzePath(e, r) { try { e = (n = FS.lookupPath(e, { follow: !r })).path } catch (e) { } var t = { isRoot: !1, exists: !1, error: 0, name: null, path: null, object: null, parentExists: !1, parentPath: null, parentObject: null }; try { var n = FS.lookupPath(e, { parent: !0 }); t.parentExists = !0, t.parentPath = n.path, t.parentObject = n.node, t.name = PATH.basename(e), n = FS.lookupPath(e, { follow: !r }), t.exists = !0, t.path = n.path, t.object = n.node, t.name = n.node.name, t.isRoot = "/" === n.path } catch (e) { t.error = e.errno } return t }, createPath(e, r, t, n) { e = "string" == typeof e ? e : FS.getPath(e); for (var o = r.split("/").reverse(); o.length;) { var a = o.pop(); if (a) { var s = PATH.join2(e, a); try { FS.mkdir(s) } catch (e) { } e = s } } return s }, createFile(e, r, t, n, o) { var a = PATH.join2("string" == typeof e ? e : FS.getPath(e), r), s = FS_getMode(n, o); return FS.create(a, s) }, createDataFile(e, r, t, n, o, a) { var s = r; e && (e = "string" == typeof e ? e : FS.getPath(e), s = r ? PATH.join2(e, r) : e); var i = FS_getMode(n, o), l = FS.create(s, i); if (t) { if ("string" == typeof t) { for (var c = new Array(t.length), d = 0, u = t.length; d < u; ++d)c[d] = t.charCodeAt(d); t = c } FS.chmod(l, 146 | i); var m = FS.open(l, 577); FS.write(m, t, 0, t.length, 0, a), FS.close(m), FS.chmod(l, i) } }, createDevice(e, r, t, n) { var o = PATH.join2("string" == typeof e ? e : FS.getPath(e), r), a = FS_getMode(!!t, !!n); FS.createDevice.major ??= 64; var s = FS.makedev(FS.createDevice.major++, 0); return FS.registerDevice(s, { open(e) { e.seekable = !1 }, close(e) { n?.buffer?.length && n(10) }, read(e, r, n, o, a) { for (var s = 0, i = 0; i < o; i++) { var l; try { l = t() } catch (e) { throw new FS.ErrnoError(29) } if (void 0 === l && 0 === s) throw new FS.ErrnoError(6); if (null == l) break; s++, r[n + i] = l } return s && (e.node.atime = Date.now()), s }, write(e, r, t, o, a) { for (var s = 0; s < o; s++)try { n(r[t + s]) } catch (e) { throw new FS.ErrnoError(29) } return o && (e.node.mtime = e.node.ctime = Date.now()), s } }), FS.mkdev(o, a, s) }, forceLoadFile(e) { if (e.isDevice || e.isFolder || e.link || e.contents) return !0; if ("undefined" != typeof XMLHttpRequest) throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."); try { e.contents = readBinary(e.url), e.usedBytes = e.contents.length } catch (e) { throw new FS.ErrnoError(29) } }, createLazyFile(e, r, t, n, o) { class a { lengthKnown = !1; chunks = []; get(e) { if (!(e > this.length - 1 || e < 0)) { var r = e % this.chunkSize, t = e / this.chunkSize | 0; return this.getter(t)[r] } } setDataGetter(e) { this.getter = e } cacheLength() { var e = new XMLHttpRequest; if (e.open("HEAD", t, !1), e.send(null), !(e.status >= 200 && e.status < 300 || 304 === e.status)) throw new Error("Couldn't load " + t + ". Status: " + e.status); var r, n = Number(e.getResponseHeader("Content-length")), o = (r = e.getResponseHeader("Accept-Ranges")) && "bytes" === r, a = (r = e.getResponseHeader("Content-Encoding")) && "gzip" === r, s = 1048576; o || (s = n); var i = this; i.setDataGetter((e => { var r = e * s, o = (e + 1) * s - 1; if (o = Math.min(o, n - 1), void 0 === i.chunks[e] && (i.chunks[e] = ((e, r) => { if (e > r) throw new Error("invalid range (" + e + ", " + r + ") or no bytes requested!"); if (r > n - 1) throw new Error("only " + n + " bytes available! programmer error!"); var o = new XMLHttpRequest; if (o.open("GET", t, !1), n !== s && o.setRequestHeader("Range", "bytes=" + e + "-" + r), o.responseType = "arraybuffer", o.overrideMimeType && o.overrideMimeType("text/plain; charset=x-user-defined"), o.send(null), !(o.status >= 200 && o.status < 300 || 304 === o.status)) throw new Error("Couldn't load " + t + ". Status: " + o.status); return void 0 !== o.response ? new Uint8Array(o.response || []) : intArrayFromString(o.responseText || "", !0) })(r, o)), void 0 === i.chunks[e]) throw new Error("doXHR failed!"); return i.chunks[e] })), !a && n || (s = n = 1, n = this.getter(0).length, s = n, out("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = n, this._chunkSize = s, this.lengthKnown = !0 } get length() { return this.lengthKnown || this.cacheLength(), this._length } get chunkSize() { return this.lengthKnown || this.cacheLength(), this._chunkSize } } if ("undefined" != typeof XMLHttpRequest) { if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"; var s = { isDevice: !1, contents: new a } } else s = { isDevice: !1, url: t }; var i = FS.createFile(e, r, s, n, o); s.contents ? i.contents = s.contents : s.url && (i.contents = null, i.url = s.url), Object.defineProperties(i, { usedBytes: { get: function () { return this.contents.length } } }); var l = {}; function c(e, r, t, n, o) { var a = e.node.contents; if (o >= a.length) return 0; var s = Math.min(a.length - o, n); if (a.slice) for (var i = 0; i < s; i++)r[t + i] = a[o + i]; else for (i = 0; i < s; i++)r[t + i] = a.get(o + i); return s } return Object.keys(i.stream_ops).forEach((e => { var r = i.stream_ops[e]; l[e] = (...e) => (FS.forceLoadFile(i), r(...e)) })), l.read = (e, r, t, n, o) => (FS.forceLoadFile(i), c(e, r, t, n, o)), l.mmap = (e, r, t, n, o) => { FS.forceLoadFile(i); var a = mmapAlloc(r); if (!a) throw new FS.ErrnoError(48); return c(e, HEAP8, a, r, t), { ptr: a, allocated: !0 } }, i.stream_ops = l, i } }, SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt(e, r, t) { if (PATH.isAbs(r)) return r; var n; -100 === e ? n = FS.cwd() : n = SYSCALLS.getStreamFromFD(e).path; if (0 == r.length) { if (!t) throw new FS.ErrnoError(44); return n } return n + "/" + r }, writeStat(e, r) { HEAP32[e >> 2] = r.dev, HEAP32[e + 4 >> 2] = r.mode, HEAPU32[e + 8 >> 2] = r.nlink, HEAP32[e + 12 >> 2] = r.uid, HEAP32[e + 16 >> 2] = r.gid, HEAP32[e + 20 >> 2] = r.rdev, HEAP64[e + 24 >> 3] = BigInt(r.size), HEAP32[e + 32 >> 2] = 4096, HEAP32[e + 36 >> 2] = r.blocks; var t = r.atime.getTime(), n = r.mtime.getTime(), o = r.ctime.getTime(); return HEAP64[e + 40 >> 3] = BigInt(Math.floor(t / 1e3)), HEAPU32[e + 48 >> 2] = t % 1e3 * 1e3 * 1e3, HEAP64[e + 56 >> 3] = BigInt(Math.floor(n / 1e3)), HEAPU32[e + 64 >> 2] = n % 1e3 * 1e3 * 1e3, HEAP64[e + 72 >> 3] = BigInt(Math.floor(o / 1e3)), HEAPU32[e + 80 >> 2] = o % 1e3 * 1e3 * 1e3, HEAP64[e + 88 >> 3] = BigInt(r.ino), 0 }, writeStatFs(e, r) { HEAP32[e + 4 >> 2] = r.bsize, HEAP32[e + 40 >> 2] = r.bsize, HEAP32[e + 8 >> 2] = r.blocks, HEAP32[e + 12 >> 2] = r.bfree, HEAP32[e + 16 >> 2] = r.bavail, HEAP32[e + 20 >> 2] = r.files, HEAP32[e + 24 >> 2] = r.ffree, HEAP32[e + 28 >> 2] = r.fsid, HEAP32[e + 44 >> 2] = r.flags, HEAP32[e + 36 >> 2] = r.namelen }, doMsync(e, r, t, n, o) { if (!FS.isFile(r.node.mode)) throw new FS.ErrnoError(43); if (2 & n) return 0; var a = HEAPU8.slice(e, e + t); FS.msync(r, a, o, t, n) }, getStreamFromFD: e => FS.getStreamChecked(e), varargs: void 0, getStr: e => UTF8ToString(e) }, ___syscall__newselect = function (e, r, t, n, o) { try { for (var a = 0, s = r ? HEAP32[r >> 2] : 0, i = r ? HEAP32[r + 4 >> 2] : 0, l = t ? HEAP32[t >> 2] : 0, c = t ? HEAP32[t + 4 >> 2] : 0, d = n ? HEAP32[n >> 2] : 0, u = n ? HEAP32[n + 4 >> 2] : 0, m = 0, S = 0, f = 0, _ = 0, F = 0, p = 0, h = (r ? HEAP32[r >> 2] : 0) | (t ? HEAP32[t >> 2] : 0) | (n ? HEAP32[n >> 2] : 0), E = (r ? HEAP32[r + 4 >> 2] : 0) | (t ? HEAP32[t + 4 >> 2] : 0) | (n ? HEAP32[n + 4 >> 2] : 0), g = (e, r, t, n) => e < 32 ? r & n : t & n, w = 0; w < e; w++) { var v = 1 << w % 32; if (g(w, h, E, v)) { var y = SYSCALLS.getStreamFromFD(w), A = SYSCALLS.DEFAULT_POLLMASK; if (y.stream_ops.poll) { var k = -1; if (o) k = 1e3 * ((r ? HEAP32[o >> 2] : 0) + (r ? HEAP32[o + 4 >> 2] : 0) / 1e6); A = y.stream_ops.poll(y, k) } 1 & A && g(w, s, i, v) && (w < 32 ? m |= v : S |= v, a++), 4 & A && g(w, l, c, v) && (w < 32 ? f |= v : _ |= v, a++), 2 & A && g(w, d, u, v) && (w < 32 ? F |= v : p |= v, a++) } } return r && (HEAP32[r >> 2] = m, HEAP32[r + 4 >> 2] = S), t && (HEAP32[t >> 2] = f, HEAP32[t + 4 >> 2] = _), n && (HEAP32[n >> 2] = F, HEAP32[n + 4 >> 2] = p), a } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } }; function ___syscall_chmod(e, r) { try { return e = SYSCALLS.getStr(e), FS.chmod(e, r), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } var SOCKFS = { callbacks: {}, on(e, r) { SOCKFS.callbacks[e] = r }, emit(e, r) { SOCKFS.callbacks[e]?.(r) }, mount: e => FS.createNode(null, "/", 16895, 0), createSocket(e, r, t) { if (1 == (r &= -526337) && t && 6 != t) throw new FS.ErrnoError(66); var n = { family: e, type: r, protocol: t, server: null, error: null, peers: {}, pending: [], recv_queue: [], sock_ops: SOCKFS.websocket_sock_ops }, o = SOCKFS.nextname(), a = FS.createNode(SOCKFS.root, o, 49152, 0); a.sock = n; var s = FS.createStream({ path: o, node: a, flags: 2, seekable: !1, stream_ops: SOCKFS.stream_ops }); return n.stream = s, n }, getSocket(e) { var r = FS.getStream(e); return r && FS.isSocket(r.node.mode) ? r.node.sock : null }, stream_ops: { poll(e) { var r = e.node.sock; return r.sock_ops.poll(r) }, ioctl(e, r, t) { var n = e.node.sock; return n.sock_ops.ioctl(n, r, t) }, read(e, r, t, n, o) { var a = e.node.sock, s = a.sock_ops.recvmsg(a, n); return s ? (r.set(s.buffer, t), s.buffer.length) : 0 }, write(e, r, t, n, o) { var a = e.node.sock; return a.sock_ops.sendmsg(a, r, t, n) }, close(e) { var r = e.node.sock; r.sock_ops.close(r) } }, nextname: () => (SOCKFS.nextname.current || (SOCKFS.nextname.current = 0), `socket[${SOCKFS.nextname.current++}]`), websocket_sock_ops: { createPeer(e, r, t) { var n; if ("object" == typeof r && (n = r, r = null, t = null), n) if (n._socket) r = n._socket.remoteAddress, t = n._socket.remotePort; else { var o = /ws[s]?:\/\/([^:]+):(\d+)/.exec(n.url); if (!o) throw new Error("WebSocket URL must be in the format ws(s)://address:port"); r = o[1], t = parseInt(o[2], 10) } else try { var a = "ws:#".replace("#", "//"), s = "binary", i = void 0; if ("ws://" === a || "wss://" === a) { var l = r.split("/"); a = a + l[0] + ":" + t + "/" + l.slice(1).join("/") } "null" !== s && (i = s = s.replace(/^ +| +$/g, "").split(/ *, */)), (n = new WebSocket(a, i)).binaryType = "arraybuffer" } catch (e) { throw new FS.ErrnoError(23) } var c = { addr: r, port: t, socket: n, msg_send_queue: [] }; return SOCKFS.websocket_sock_ops.addPeer(e, c), SOCKFS.websocket_sock_ops.handlePeerEvents(e, c), 2 === e.type && void 0 !== e.sport && c.msg_send_queue.push(new Uint8Array([255, 255, 255, 255, "p".charCodeAt(0), "o".charCodeAt(0), "r".charCodeAt(0), "t".charCodeAt(0), (65280 & e.sport) >> 8, 255 & e.sport])), c }, getPeer: (e, r, t) => e.peers[r + ":" + t], addPeer(e, r) { e.peers[r.addr + ":" + r.port] = r }, removePeer(e, r) { delete e.peers[r.addr + ":" + r.port] }, handlePeerEvents(e, r) { var t = !0, n = function () { e.connecting = !1, SOCKFS.emit("open", e.stream.fd); try { for (var t = r.msg_send_queue.shift(); t;)r.socket.send(t), t = r.msg_send_queue.shift() } catch (e) { r.socket.close() } }; function o(n) { if ("string" == typeof n) { n = (new TextEncoder).encode(n) } else { if (assert(void 0 !== n.byteLength), 0 == n.byteLength) return; n = new Uint8Array(n) } var o = t; if (t = !1, o && 10 === n.length && 255 === n[0] && 255 === n[1] && 255 === n[2] && 255 === n[3] && n[4] === "p".charCodeAt(0) && n[5] === "o".charCodeAt(0) && n[6] === "r".charCodeAt(0) && n[7] === "t".charCodeAt(0)) { var a = n[8] << 8 | n[9]; return SOCKFS.websocket_sock_ops.removePeer(e, r), r.port = a, void SOCKFS.websocket_sock_ops.addPeer(e, r) } e.recv_queue.push({ addr: r.addr, port: r.port, data: n }), SOCKFS.emit("message", e.stream.fd) } ENVIRONMENT_IS_NODE ? (r.socket.on("open", n), r.socket.on("message", (function (e, r) { r && o(new Uint8Array(e).buffer) })), r.socket.on("close", (function () { SOCKFS.emit("close", e.stream.fd) })), r.socket.on("error", (function (r) { e.error = 14, SOCKFS.emit("error", [e.stream.fd, e.error, "ECONNREFUSED: Connection refused"]) }))) : (r.socket.onopen = n, r.socket.onclose = function () { SOCKFS.emit("close", e.stream.fd) }, r.socket.onmessage = function (e) { o(e.data) }, r.socket.onerror = function (r) { e.error = 14, SOCKFS.emit("error", [e.stream.fd, e.error, "ECONNREFUSED: Connection refused"]) }) }, poll(e) { if (1 === e.type && e.server) return e.pending.length ? 65 : 0; var r = 0, t = 1 === e.type ? SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport) : null; return (e.recv_queue.length || !t || t && t.socket.readyState === t.socket.CLOSING || t && t.socket.readyState === t.socket.CLOSED) && (r |= 65), (!t || t && t.socket.readyState === t.socket.OPEN) && (r |= 4), (t && t.socket.readyState === t.socket.CLOSING || t && t.socket.readyState === t.socket.CLOSED) && (e.connecting ? r |= 4 : r |= 16), r }, ioctl(e, r, t) { if (21531 === r) { var n = 0; return e.recv_queue.length && (n = e.recv_queue[0].data.length), HEAP32[t >> 2] = n, 0 } return 28 }, close(e) { if (e.server) { try { e.server.close() } catch (e) { } e.server = null } for (var r = Object.keys(e.peers), t = 0; t < r.length; t++) { var n = e.peers[r[t]]; try { n.socket.close() } catch (e) { } SOCKFS.websocket_sock_ops.removePeer(e, n) } return 0 }, bind(e, r, t) { if (void 0 !== e.saddr || void 0 !== e.sport) throw new FS.ErrnoError(28); if (e.saddr = r, e.sport = t, 2 === e.type) { e.server && (e.server.close(), e.server = null); try { e.sock_ops.listen(e, 0) } catch (e) { if ("ErrnoError" !== e.name) throw e; if (138 !== e.errno) throw e } } }, connect(e, r, t) { if (e.server) throw new FS.ErrnoError(138); if (void 0 !== e.daddr && void 0 !== e.dport) { var n = SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport); if (n) throw n.socket.readyState === n.socket.CONNECTING ? new FS.ErrnoError(7) : new FS.ErrnoError(30) } var o = SOCKFS.websocket_sock_ops.createPeer(e, r, t); e.daddr = o.addr, e.dport = o.port, e.connecting = !0 }, listen(e, r) { if (!ENVIRONMENT_IS_NODE) throw new FS.ErrnoError(138) }, accept(e) { if (!e.server || !e.pending.length) throw new FS.ErrnoError(28); var r = e.pending.shift(); return r.stream.flags = e.stream.flags, r }, getname(e, r) { var t, n; if (r) { if (void 0 === e.daddr || void 0 === e.dport) throw new FS.ErrnoError(53); t = e.daddr, n = e.dport } else t = e.saddr || 0, n = e.sport || 0; return { addr: t, port: n } }, sendmsg(e, r, t, n, o, a) { if (2 === e.type) { if (void 0 !== o && void 0 !== a || (o = e.daddr, a = e.dport), void 0 === o || void 0 === a) throw new FS.ErrnoError(17) } else o = e.daddr, a = e.dport; var s = SOCKFS.websocket_sock_ops.getPeer(e, o, a); if (1 === e.type && (!s || s.socket.readyState === s.socket.CLOSING || s.socket.readyState === s.socket.CLOSED)) throw new FS.ErrnoError(53); ArrayBuffer.isView(r) && (t += r.byteOffset, r = r.buffer); var i = r.slice(t, t + n); if (!s || s.socket.readyState !== s.socket.OPEN) return 2 === e.type && (s && s.socket.readyState !== s.socket.CLOSING && s.socket.readyState !== s.socket.CLOSED || (s = SOCKFS.websocket_sock_ops.createPeer(e, o, a))), s.msg_send_queue.push(i), n; try { return s.socket.send(i), n } catch (e) { throw new FS.ErrnoError(28) } }, recvmsg(e, r) { if (1 === e.type && e.server) throw new FS.ErrnoError(53); var t = e.recv_queue.shift(); if (!t) { if (1 === e.type) { var n = SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport); if (!n) throw new FS.ErrnoError(53); if (n.socket.readyState === n.socket.CLOSING || n.socket.readyState === n.socket.CLOSED) return null; throw new FS.ErrnoError(6) } throw new FS.ErrnoError(6) } var o = t.data.byteLength || t.data.length, a = t.data.byteOffset || 0, s = t.data.buffer || t.data, i = Math.min(r, o), l = { buffer: new Uint8Array(s, a, i), addr: t.addr, port: t.port }; if (1 === e.type && i < o) { var c = o - i; t.data = new Uint8Array(s, a + i, c), e.recv_queue.unshift(t) } return l } } }, getSocketFromFD = e => { var r = SOCKFS.getSocket(e); if (!r) throw new FS.ErrnoError(8); return r }, inetNtop4 = e => (255 & e) + "." + (e >> 8 & 255) + "." + (e >> 16 & 255) + "." + (e >> 24 & 255), inetNtop6 = e => { var r = "", t = 0, n = 0, o = 0, a = 0, s = 0, i = 0, l = [65535 & e[0], e[0] >> 16, 65535 & e[1], e[1] >> 16, 65535 & e[2], e[2] >> 16, 65535 & e[3], e[3] >> 16], c = !0, d = ""; for (i = 0; i < 5; i++)if (0 !== l[i]) { c = !1; break } if (c) { if (d = inetNtop4(l[6] | l[7] << 16), -1 === l[5]) return r = "::ffff:", r += d; if (0 === l[5]) return r = "::", "0.0.0.0" === d && (d = ""), "0.0.0.1" === d && (d = "1"), r += d } for (t = 0; t < 8; t++)0 === l[t] && (t - o > 1 && (s = 0), o = t, s++), s > n && (a = t - (n = s) + 1); for (t = 0; t < 8; t++)n > 1 && 0 === l[t] && t >= a && t < a + n ? t === a && (r += ":", 0 === a && (r += ":")) : (r += Number(_ntohs(65535 & l[t])).toString(16), r += t < 7 ? ":" : ""); return r }, readSockaddr = (e, r) => { var t, n = HEAP16[e >> 1], o = _ntohs(HEAPU16[e + 2 >> 1]); switch (n) { case 2: if (16 !== r) return { errno: 28 }; t = HEAP32[e + 4 >> 2], t = inetNtop4(t); break; case 10: if (28 !== r) return { errno: 28 }; t = [HEAP32[e + 8 >> 2], HEAP32[e + 12 >> 2], HEAP32[e + 16 >> 2], HEAP32[e + 20 >> 2]], t = inetNtop6(t); break; default: return { errno: 5 } }return { family: n, addr: t, port: o } }, inetPton4 = e => { for (var r = e.split("."), t = 0; t < 4; t++) { var n = Number(r[t]); if (isNaN(n)) return null; r[t] = n } return (r[0] | r[1] << 8 | r[2] << 16 | r[3] << 24) >>> 0 }, jstoi_q = e => parseInt(e), inetPton6 = e => { var r, t, n, o, a = []; if (!/^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i.test(e)) return null; if ("::" === e) return [0, 0, 0, 0, 0, 0, 0, 0]; for ((e = e.startsWith("::") ? e.replace("::", "Z:") : e.replace("::", ":Z:")).indexOf(".") > 0 ? ((r = (e = e.replace(new RegExp("[.]", "g"), ":")).split(":"))[r.length - 4] = jstoi_q(r[r.length - 4]) + 256 * jstoi_q(r[r.length - 3]), r[r.length - 3] = jstoi_q(r[r.length - 2]) + 256 * jstoi_q(r[r.length - 1]), r = r.slice(0, r.length - 2)) : r = e.split(":"), n = 0, o = 0, t = 0; t < r.length; t++)if ("string" == typeof r[t]) if ("Z" === r[t]) { for (o = 0; o < 8 - r.length + 1; o++)a[t + o] = 0; n = o - 1 } else a[t + n] = _htons(parseInt(r[t], 16)); else a[t + n] = r[t]; return [a[1] << 16 | a[0], a[3] << 16 | a[2], a[5] << 16 | a[4], a[7] << 16 | a[6]] }, DNS = { address_map: { id: 1, addrs: {}, names: {} }, lookup_name(e) { var r, t = inetPton4(e); if (null !== t) return e; if (null !== (t = inetPton6(e))) return e; if (DNS.address_map.addrs[e]) r = DNS.address_map.addrs[e]; else { var n = DNS.address_map.id++; assert(n < 65535, "exceeded max address mappings of 65535"), r = "172.29." + (255 & n) + "." + (65280 & n), DNS.address_map.names[r] = e, DNS.address_map.addrs[e] = r } return r }, lookup_addr: e => DNS.address_map.names[e] ? DNS.address_map.names[e] : null }, getSocketAddress = (e, r) => { var t = readSockaddr(e, r); if (t.errno) throw new FS.ErrnoError(t.errno); return t.addr = DNS.lookup_addr(t.addr) || t.addr, t }; function ___syscall_connect(e, r, t, n, o, a) { try { var s = getSocketFromFD(e), i = getSocketAddress(r, t); return s.sock_ops.connect(s, i.addr, i.port), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_fchmod(e, r) { try { return FS.fchmod(e, r), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } var syscallGetVarargI = () => { var e = HEAP32[+SYSCALLS.varargs >> 2]; return SYSCALLS.varargs += 4, e }, syscallGetVarargP = syscallGetVarargI; function ___syscall_fcntl64(e, r, t) { SYSCALLS.varargs = t; try { var n = SYSCALLS.getStreamFromFD(e); switch (r) { case 0: if ((o = syscallGetVarargI()) < 0) return -28; for (; FS.streams[o];)o++; return FS.dupStream(n, o).fd; case 1: case 2: case 13: case 14: return 0; case 3: return n.flags; case 4: var o = syscallGetVarargI(); return n.flags |= o, 0; case 12: o = syscallGetVarargP(); return HEAP16[o + 0 >> 1] = 2, 0 }return -28 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_fstat64(e, r) { try { return SYSCALLS.writeStat(r, FS.fstat(e)) } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } var INT53_MAX = 9007199254740992, INT53_MIN = -9007199254740992, bigintToI53Checked = e => e < INT53_MIN || e > INT53_MAX ? NaN : Number(e); function ___syscall_ftruncate64(e, r) { r = bigintToI53Checked(r); try { return isNaN(r) ? 61 : (FS.ftruncate(e, r), 0) } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } var stringToUTF8 = (e, r, t) => stringToUTF8Array(e, HEAPU8, r, t); function ___syscall_getdents64(e, r, t) { try { var n = SYSCALLS.getStreamFromFD(e); n.getdents ||= FS.readdir(n.path); for (var o = 280, a = 0, s = FS.llseek(n, 0, 1), i = Math.floor(s / o), l = Math.min(n.getdents.length, i + Math.floor(t / o)), c = i; c < l; c++) { var d, u, m = n.getdents[c]; if ("." === m) d = n.node.id, u = 4; else if (".." === m) { d = FS.lookupPath(n.path, { parent: !0 }).node.id, u = 4 } else { var S; try { S = FS.lookupNode(n.node, m) } catch (e) { if (28 === e?.errno) continue; throw e } d = S.id, u = FS.isChrdev(S.mode) ? 2 : FS.isDir(S.mode) ? 4 : FS.isLink(S.mode) ? 10 : 8 } HEAP64[r + a >> 3] = BigInt(d), HEAP64[r + a + 8 >> 3] = BigInt((c + 1) * o), HEAP16[r + a + 16 >> 1] = 280, HEAP8[r + a + 18] = u, stringToUTF8(m, r + a + 19, 256), a += o } return FS.llseek(n, c * o, 0), a } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_getuid32() { abort("missing function: __syscall_getuid32") } function ___syscall_ioctl(e, r, t) { SYSCALLS.varargs = t; try { var n = SYSCALLS.getStreamFromFD(e); switch (r) { case 21509: case 21510: case 21511: case 21512: case 21524: case 21515: return n.tty ? 0 : -59; case 21505: if (!n.tty) return -59; if (n.tty.ops.ioctl_tcgets) { var o = n.tty.ops.ioctl_tcgets(n), a = syscallGetVarargP(); HEAP32[a >> 2] = o.c_iflag || 0, HEAP32[a + 4 >> 2] = o.c_oflag || 0, HEAP32[a + 8 >> 2] = o.c_cflag || 0, HEAP32[a + 12 >> 2] = o.c_lflag || 0; for (var s = 0; s < 32; s++)HEAP8[a + s + 17] = o.c_cc[s] || 0; return 0 } return 0; case 21506: case 21507: case 21508: if (!n.tty) return -59; if (n.tty.ops.ioctl_tcsets) { a = syscallGetVarargP(); var i = HEAP32[a >> 2], l = HEAP32[a + 4 >> 2], c = HEAP32[a + 8 >> 2], d = HEAP32[a + 12 >> 2], u = []; for (s = 0; s < 32; s++)u.push(HEAP8[a + s + 17]); return n.tty.ops.ioctl_tcsets(n.tty, r, { c_iflag: i, c_oflag: l, c_cflag: c, c_lflag: d, c_cc: u }) } return 0; case 21519: if (!n.tty) return -59; a = syscallGetVarargP(); return HEAP32[a >> 2] = 0, 0; case 21520: return n.tty ? -28 : -59; case 21531: a = syscallGetVarargP(); return FS.ioctl(n, r, a); case 21523: if (!n.tty) return -59; if (n.tty.ops.ioctl_tiocgwinsz) { var m = n.tty.ops.ioctl_tiocgwinsz(n.tty); a = syscallGetVarargP(); HEAP16[a >> 1] = m[0], HEAP16[a + 2 >> 1] = m[1] } return 0; default: return -28 } } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_linkat() { abort("missing function: __syscall_linkat") } function ___syscall_lstat64(e, r) { try { return e = SYSCALLS.getStr(e), SYSCALLS.writeStat(r, FS.lstat(e)) } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_mkdirat(e, r, t) { try { return r = SYSCALLS.getStr(r), r = SYSCALLS.calculateAt(e, r), FS.mkdir(r, t, 0), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_newfstatat(e, r, t, n) { try { r = SYSCALLS.getStr(r); var o = 256 & n, a = 4096 & n; return n &= -6401, r = SYSCALLS.calculateAt(e, r, a), SYSCALLS.writeStat(t, o ? FS.lstat(r) : FS.stat(r)) } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_openat(e, r, t, n) { SYSCALLS.varargs = n; try { r = SYSCALLS.getStr(r), r = SYSCALLS.calculateAt(e, r); var o = n ? syscallGetVarargI() : 0; return FS.open(r, t, o).fd } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_readlinkat(e, r, t, n) { try { if (r = SYSCALLS.getStr(r), r = SYSCALLS.calculateAt(e, r), n <= 0) return -28; var o = FS.readlink(r), a = Math.min(n, lengthBytesUTF8(o)), s = HEAP8[t + a]; return stringToUTF8(o, t, n + 1), HEAP8[t + a] = s, a } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_socket(e, r, t) { try { return SOCKFS.createSocket(e, r, t).stream.fd } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_stat64(e, r) { try { return e = SYSCALLS.getStr(e), SYSCALLS.writeStat(r, FS.stat(e)) } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } function ___syscall_symlinkat(e, r, t) { try { return e = SYSCALLS.getStr(e), t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(r, t), FS.symlink(e, t), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return -e.errno } } ___syscall_getuid32.stub = !0, ___syscall_linkat.stub = !0; var __abort_js = () => abort(""), runtimeKeepaliveCounter = 0, __emscripten_runtime_keepalive_clear = () => { runtimeKeepaliveCounter = 0 }; function __gmtime_js(e, r) { e = bigintToI53Checked(e); var t = new Date(1e3 * e); HEAP32[r >> 2] = t.getUTCSeconds(), HEAP32[r + 4 >> 2] = t.getUTCMinutes(), HEAP32[r + 8 >> 2] = t.getUTCHours(), HEAP32[r + 12 >> 2] = t.getUTCDate(), HEAP32[r + 16 >> 2] = t.getUTCMonth(), HEAP32[r + 20 >> 2] = t.getUTCFullYear() - 1900, HEAP32[r + 24 >> 2] = t.getUTCDay(); var n = Date.UTC(t.getUTCFullYear(), 0, 1, 0, 0, 0, 0), o = (t.getTime() - n) / 864e5 | 0; HEAP32[r + 28 >> 2] = o } var isLeapYear = e => e % 4 == 0 && (e % 100 != 0 || e % 400 == 0), MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], ydayFromDate = e => (isLeapYear(e.getFullYear()) ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE)[e.getMonth()] + e.getDate() - 1; function __localtime_js(e, r) { e = bigintToI53Checked(e); var t = new Date(1e3 * e); HEAP32[r >> 2] = t.getSeconds(), HEAP32[r + 4 >> 2] = t.getMinutes(), HEAP32[r + 8 >> 2] = t.getHours(), HEAP32[r + 12 >> 2] = t.getDate(), HEAP32[r + 16 >> 2] = t.getMonth(), HEAP32[r + 20 >> 2] = t.getFullYear() - 1900, HEAP32[r + 24 >> 2] = t.getDay(); var n = 0 | ydayFromDate(t); HEAP32[r + 28 >> 2] = n, HEAP32[r + 36 >> 2] = -60 * t.getTimezoneOffset(); var o = new Date(t.getFullYear(), 0, 1), a = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(), s = o.getTimezoneOffset(), i = 0 | (a != s && t.getTimezoneOffset() == Math.min(s, a)); HEAP32[r + 32 >> 2] = i } var timers = {}, handleException = e => { if (e instanceof ExitStatus || "unwind" == e) return EXITSTATUS; quit_(1, e) }, keepRuntimeAlive = () => !0, _proc_exit = e => { EXITSTATUS = e, keepRuntimeAlive() || (ABORT = !0), quit_(e, new ExitStatus(e)) }, exitJS = (e, r) => { EXITSTATUS = e, _proc_exit(e) }, _exit = exitJS, maybeExit = () => { if (!keepRuntimeAlive()) try { _exit(EXITSTATUS) } catch (e) { handleException(e) } }, callUserCallback = e => { if (!ABORT) try { e(), maybeExit() } catch (e) { handleException(e) } }, _emscripten_get_now = () => performance.now(), __setitimer_js = (e, r) => { if (timers[e] && (clearTimeout(timers[e].id), delete timers[e]), !r) return 0; var t = setTimeout((() => { delete timers[e], callUserCallback((() => __emscripten_timeout(e, _emscripten_get_now()))) }), r); return timers[e] = { id: t, timeout_ms: r }, 0 }, __tzset_js = (e, r, t, n) => { var o = (new Date).getFullYear(), a = new Date(o, 0, 1), s = new Date(o, 6, 1), i = a.getTimezoneOffset(), l = s.getTimezoneOffset(), c = Math.max(i, l); HEAPU32[e >> 2] = 60 * c, HEAP32[r >> 2] = Number(i != l); var d = e => { var r = e >= 0 ? "-" : "+", t = Math.abs(e); return `UTC${r}${String(Math.floor(t / 60)).padStart(2, "0")}${String(t % 60).padStart(2, "0")}` }, u = d(i), m = d(l); l < i ? (stringToUTF8(u, t, 17), stringToUTF8(m, n, 17)) : (stringToUTF8(u, n, 17), stringToUTF8(m, t, 17)) }, _emscripten_date_now = () => Date.now(), nowIsMonotonic = 1, checkWasiClock = e => e >= 0 && e <= 3; function _clock_time_get(e, r, t) { if (r = bigintToI53Checked(r), !checkWasiClock(e)) return 28; var n; if (0 === e) n = _emscripten_date_now(); else { if (!nowIsMonotonic) return 52; n = _emscripten_get_now() } var o = Math.round(1e3 * n * 1e3); return HEAP64[t >> 3] = BigInt(o), 0 } var reallyNegative = e => e < 0 || 0 === e && 1 / e == -1 / 0, convertI32PairToI53 = (e, r) => (e >>> 0) + 4294967296 * r, convertU32PairToI53 = (e, r) => (e >>> 0) + 4294967296 * (r >>> 0), reSign = (e, r) => { if (e <= 0) return e; var t = r <= 32 ? Math.abs(1 << r - 1) : Math.pow(2, r - 1); return e >= t && (r <= 32 || e > t) && (e = -2 * t + e), e }, unSign = (e, r) => e >= 0 ? e : r <= 32 ? 2 * Math.abs(1 << r - 1) + e : Math.pow(2, r) + e, strLen = e => { for (var r = e; HEAPU8[r];)++r; return r - e }, formatString = (e, r) => { var t = e, n = r; function o(e) { var r; return n = function (e, r) { return "double" !== r && "i64" !== r || 7 & e && (e += 4), e }(n, e), "double" === e ? (r = HEAPF64[n >> 3], n += 8) : "i64" == e ? (r = [HEAP32[n >> 2], HEAP32[n + 4 >> 2]], n += 8) : (e = "i32", r = HEAP32[n >> 2], n += 4), r } for (var a, s, i, l = []; ;) { var c = t; if (0 === (a = HEAP8[t])) break; if (s = HEAP8[t + 1], 37 == a) { var d = !1, u = !1, m = !1, S = !1, f = !1; e: for (; ;) { switch (s) { case 43: d = !0; break; case 45: u = !0; break; case 35: m = !0; break; case 48: if (S) break e; S = !0; break; case 32: f = !0; break; default: break e }t++, s = HEAP8[t + 1] } var _ = 0; if (42 == s) _ = o("i32"), t++, s = HEAP8[t + 1]; else for (; s >= 48 && s <= 57;)_ = 10 * _ + (s - 48), t++, s = HEAP8[t + 1]; var F, p = !1, h = -1; if (46 == s) { if (h = 0, p = !0, t++, 42 == (s = HEAP8[t + 1])) h = o("i32"), t++; else for (; ;) { var E = HEAP8[t + 1]; if (E < 48 || E > 57) break; h = 10 * h + (E - 48), t++ } s = HEAP8[t + 1] } switch (h < 0 && (h = 6, p = !1), String.fromCharCode(s)) { case "h": 104 == HEAP8[t + 2] ? (t++, F = 1) : F = 2; break; case "l": 108 == HEAP8[t + 2] ? (t++, F = 8) : F = 4; break; case "L": case "q": case "j": F = 8; break; case "z": case "t": case "I": F = 4; break; default: F = null }switch (F && t++, s = HEAP8[t + 1], String.fromCharCode(s)) { case "d": case "i": case "u": case "o": case "x": case "X": case "p": var g = 100 == s || 105 == s; if (i = o("i" + 8 * (F = F || 4)), 8 == F && (i = 117 == s ? convertU32PairToI53(i[0], i[1]) : convertI32PairToI53(i[0], i[1])), F <= 4) { var w = Math.pow(256, F) - 1; i = (g ? reSign : unSign)(i & w, 8 * F) } var v = Math.abs(i), y = ""; if (100 == s || 105 == s) T = reSign(i, 8 * F).toString(10); else if (117 == s) T = unSign(i, 8 * F).toString(10), i = Math.abs(i); else if (111 == s) T = (m ? "0" : "") + v.toString(8); else if (120 == s || 88 == s) { if (y = m && 0 != i ? "0x" : "", i < 0) { i = -i, T = (v - 1).toString(16); for (var A = [], k = 0; k < T.length; k++)A.push((15 - parseInt(T[k], 16)).toString(16)); for (T = A.join(""); T.length < 2 * F;)T = "f" + T } else T = v.toString(16); 88 == s && (y = y.toUpperCase(), T = T.toUpperCase()) } else 112 == s && (0 === v ? T = "(nil)" : (y = "0x", T = v.toString(16))); if (p) for (; T.length < h;)T = "0" + T; for (i >= 0 && (d ? y = "+" + y : f && (y = " " + y)), "-" == T.charAt(0) && (y = "-" + y, T = T.slice(1)); y.length + T.length < _;)u ? T += " " : S ? T = "0" + T : y = " " + y; (T = y + T).split("").forEach((e => l.push(e.charCodeAt(0)))); break; case "f": case "F": case "e": case "E": case "g": case "G": var T; if (i = o("double"), isNaN(i)) T = "nan", S = !1; else if (isFinite(i)) { var P = !1, b = Math.min(h, 20); if (103 == s || 71 == s) { P = !0, h = h || 1; var M = parseInt(i.toExponential(b).split("e")[1], 10); h > M && M >= -4 ? (s = (103 == s ? "f" : "F").charCodeAt(0), h -= M + 1) : (s = (103 == s ? "e" : "E").charCodeAt(0), h--), b = Math.min(h, 20) } 101 == s || 69 == s ? (T = i.toExponential(b), /[eE][-+]\d$/.test(T) && (T = T.slice(0, -1) + "0" + T.slice(-1))) : 102 != s && 70 != s || (T = i.toFixed(b), 0 === i && reallyNegative(i) && (T = "-" + T)); var C = T.split("e"); if (P && !m) for (; C[0].length > 1 && C[0].includes(".") && ("0" == C[0].slice(-1) || "." == C[0].slice(-1));)C[0] = C[0].slice(0, -1); else for (m && -1 == T.indexOf(".") && (C[0] += "."); h > b++;)C[0] += "0"; T = C[0] + (C.length > 1 ? "e" + C[1] : ""), 69 == s && (T = T.toUpperCase()), i >= 0 && (d ? T = "+" + T : f && (T = " " + T)) } else T = (i < 0 ? "-" : "") + "inf", S = !1; for (; T.length < _;)u ? T += " " : T = !S || "-" != T[0] && "+" != T[0] ? (S ? "0" : " ") + T : T[0] + "0" + T.slice(1); s < 97 && (T = T.toUpperCase()), T.split("").forEach((e => l.push(e.charCodeAt(0)))); break; case "s": var D = o("i8*"), H = D ? strLen(D) : 6; if (p && (H = Math.min(H, h)), !u) for (; H < _--;)l.push(32); if (D) for (k = 0; k < H; k++)l.push(HEAPU8[D++]); else l = l.concat(intArrayFromString("(null)".slice(0, H), !0)); if (u) for (; H < _--;)l.push(32); break; case "c": for (u && l.push(o("i8")); --_ > 0;)l.push(32); u || l.push(o("i8")); break; case "n": var N = o("i32*"); HEAP32[N >> 2] = l.length; break; case "%": l.push(a); break; default: for (k = c; k < t + 2; k++)l.push(HEAP8[k]) }t += 2 } else l.push(a), t += 1 } return l }, jsStackTrace = () => (new Error).stack.toString(), warnOnce = e => { warnOnce.shown ||= {}, warnOnce.shown[e] || (warnOnce.shown[e] = 1, err(e)) }, getCallstack = e => { var r = jsStackTrace(), t = r.lastIndexOf("_emscripten_log"), n = r.lastIndexOf("_emscripten_get_callstack"), o = r.indexOf("\n", Math.max(t, n)) + 1; r = r.slice(o), 8 & e && "undefined" == typeof emscripten_source_map && (warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.'), e ^= 8, e |= 16); var a = r.split("\n"); r = ""; var s = new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)"), i = new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?"), l = new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)"); for (var c in a) { var d = a[c], u = "", m = "", S = 0, f = 0, _ = l.exec(d); if (5 == _?.length) u = _[1], m = _[2], S = _[3], f = _[4]; else { if (_ = s.exec(d) || i.exec(d), !(_?.length >= 4)) { r += d + "\n"; continue } u = _[1], m = _[2], S = _[3], f = 0 | _[4] } var F = !1; if (8 & e) { var p = emscripten_source_map.originalPositionFor({ line: S, column: f }); F = p?.source, F && (64 & e && (p.source = p.source.substring(p.source.replace(/\\/g, "/").lastIndexOf("/") + 1)), r += `    at ${u} (${p.source}:${p.line}:${p.column})\n`) } (16 & e || !F) && (64 & e && (m = m.substring(m.replace(/\\/g, "/").lastIndexOf("/") + 1)), r += (F ? `     = ${u}` : `    at ${u}`) + ` (${m}:${S}:${f})\n`) } return r = r.replace(/\s+$/, "") }, emscriptenLog = (e, r) => { 24 & e && (r = r.replace(/\s+$/, ""), r += (r.length > 0 ? "\n" : "") + getCallstack(e)), 1 & e ? 4 & e || 2 & e ? err(r) : out(r) : 6 & e ? err(r) : out(r) }, _emscripten_log = (e, r, t) => { var n = formatString(r, t), o = UTF8ArrayToString(n); emscriptenLog(e, o) }, getHeapMax = () => 2147483648, growMemory = e => { var r = (e - wasmMemory.buffer.byteLength + 65535) / 65536 | 0; try { return wasmMemory.grow(r), updateMemoryViews(), 1 } catch (e) { } }, _emscripten_resize_heap = e => { var r = HEAPU8.length; e >>>= 0; var t = getHeapMax(); if (e > t) return !1; for (var n = 1; n <= 4; n *= 2) { var o = r * (1 + .2 / n); o = Math.min(o, e + 100663296); var a = Math.min(t, alignMemory(Math.max(e, o), 65536)); if (growMemory(a)) return !0 } return !1 }, ENV = {}, getExecutableName = () => thisProgram || "./this.program", getEnvStrings = () => { if (!getEnvStrings.strings) { var e = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: getExecutableName() }; for (var r in ENV) void 0 === ENV[r] ? delete e[r] : e[r] = ENV[r]; var t = []; for (var r in e) t.push(`${r}=${e[r]}`); getEnvStrings.strings = t } return getEnvStrings.strings }, stringToAscii = (e, r) => { for (var t = 0; t < e.length; ++t)HEAP8[r++] = e.charCodeAt(t); HEAP8[r] = 0 }, _environ_get = (e, r) => { var t = 0; return getEnvStrings().forEach(((n, o) => { var a = r + t; HEAPU32[e + 4 * o >> 2] = a, stringToAscii(n, a), t += n.length + 1 })), 0 }, _environ_sizes_get = (e, r) => { var t = getEnvStrings(); HEAPU32[e >> 2] = t.length; var n = 0; return t.forEach((e => n += e.length + 1)), HEAPU32[r >> 2] = n, 0 }; function _fd_close(e) { try { var r = SYSCALLS.getStreamFromFD(e); return FS.close(r), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return e.errno } } function _fd_fdstat_get(e, r) { try { var t = SYSCALLS.getStreamFromFD(e), n = t.tty ? 2 : FS.isDir(t.mode) ? 3 : FS.isLink(t.mode) ? 7 : 4; return HEAP8[r] = n, HEAP16[r + 2 >> 1] = 0, HEAP64[r + 8 >> 3] = BigInt(0), HEAP64[r + 16 >> 3] = BigInt(0), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return e.errno } } var doReadv = (e, r, t, n) => { for (var o = 0, a = 0; a < t; a++) { var s = HEAPU32[r >> 2], i = HEAPU32[r + 4 >> 2]; r += 8; var l = FS.read(e, HEAP8, s, i, n); if (l < 0) return -1; if (o += l, l < i) break; void 0 !== n && (n += l) } return o }; function _fd_read(e, r, t, n) { try { var o = SYSCALLS.getStreamFromFD(e), a = doReadv(o, r, t); return HEAPU32[n >> 2] = a, 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return e.errno } } function _fd_seek(e, r, t, n) { r = bigintToI53Checked(r); try { if (isNaN(r)) return 61; var o = SYSCALLS.getStreamFromFD(e); return FS.llseek(o, r, t), HEAP64[n >> 3] = BigInt(o.position), o.getdents && 0 === r && 0 === t && (o.getdents = null), 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return e.errno } } var doWritev = (e, r, t, n) => { for (var o = 0, a = 0; a < t; a++) { var s = HEAPU32[r >> 2], i = HEAPU32[r + 4 >> 2]; r += 8; var l = FS.write(e, HEAP8, s, i, n); if (l < 0) return -1; if (o += l, l < i) break; void 0 !== n && (n += l) } return o }; function _fd_write(e, r, t, n) { try { var o = SYSCALLS.getStreamFromFD(e), a = doWritev(o, r, t); return HEAPU32[n >> 2] = a, 0 } catch (e) { if (void 0 === FS || "ErrnoError" !== e.name) throw e; return e.errno } } var functionsInTableMap, uleb128Encode = (e, r) => { e < 128 ? r.push(e) : r.push(e % 128 | 128, e >> 7) }, sigToWasmTypes = e => { for (var r = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" }, t = { parameters: [], results: "v" == e[0] ? [] : [r[e[0]]] }, n = 1; n < e.length; ++n)t.parameters.push(r[e[n]]); return t }, generateFuncType = (e, r) => { var t = e.slice(0, 1), n = e.slice(1), o = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 }; r.push(96), uleb128Encode(n.length, r); for (var a = 0; a < n.length; ++a)r.push(o[n[a]]); "v" == t ? r.push(0) : r.push(1, o[t]) }, convertJsFunctionToWasm = (e, r) => { if ("function" == typeof WebAssembly.Function) return new WebAssembly.Function(sigToWasmTypes(r), e); var t = [1]; generateFuncType(r, t); var n = [0, 97, 115, 109, 1, 0, 0, 0, 1]; uleb128Encode(t.length, n), n.push(...t), n.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0); var o = new WebAssembly.Module(new Uint8Array(n)); return new WebAssembly.Instance(o, { e: { f: e } }).exports.f }, updateTableMap = (e, r) => { if (functionsInTableMap) for (var t = e; t < e + r; t++) { var n = getWasmTableEntry(t); n && functionsInTableMap.set(n, t) } }, getFunctionAddress = e => (functionsInTableMap || (functionsInTableMap = new WeakMap, updateTableMap(0, wasmTable.length)), functionsInTableMap.get(e) || 0), freeTableIndexes = [], getEmptyTableSlot = () => { if (freeTableIndexes.length) return freeTableIndexes.pop(); try { wasmTable.grow(1) } catch (e) { if (!(e instanceof RangeError)) throw e; throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." } return wasmTable.length - 1 }, setWasmTableEntry = (e, r) => wasmTable.set(e, r), addFunction = (e, r) => { var t = getFunctionAddress(e); if (t) return t; var n = getEmptyTableSlot(); try { setWasmTableEntry(n, e) } catch (t) { if (!(t instanceof TypeError)) throw t; var o = convertJsFunctionToWasm(e, r); setWasmTableEntry(n, o) } return functionsInTableMap.set(e, n), n }; FS.createPreloadedFile = FS_createPreloadedFile, FS.staticInit(), MEMFS.doesNotExistError = new FS.ErrnoError(44), MEMFS.doesNotExistError.stack = "<generic error, no stack>"; var wasmExports, a = () => { }, wasmImports = { CreateDirectoryFetcher: a, DDN_ConvertElement: a, DDN_CreateDDNResult: a, DDN_CreateDDNResultItem: a, DDN_CreateParameters: a, DDN_CreateTargetRoiDefConditionFilter: a, DDN_CreateTaskAlgEntity: a, DDN_HasSection: a, DDN_ReadTaskSetting: a, DLR_ConvertElement: a, DLR_CreateBufferedCharacterItemSet: a, DLR_CreateParameters: a, DLR_CreateRecognizedTextLinesResult: a, DLR_CreateTargetRoiDefConditionFilter: a, DLR_CreateTaskAlgEntity: a, DLR_CreateTextLineResultItem: a, DLR_ReadTaskSetting: a, DMImage_GetDIB: a, DMImage_GetFormatFromHandle: a, DMImage_GetFormatFromStream: a, DMImage_GetOrientation: a, DeleteDirectoryFetcher: a, _Z22DM_GetNodeFromFormatID15DM_IMAGE_FORMAT: a, _ZN11DMImageNode9SetHandleEPvj: a, _ZN19LabelRecognizerWasm10getVersionEv: a, _ZN19LabelRecognizerWasm12DlrWasmClass15clearVerifyListEv: a, _ZN19LabelRecognizerWasm12DlrWasmClass22getDuplicateForgetTimeEv: a, _ZN19LabelRecognizerWasm12DlrWasmClass22setDuplicateForgetTimeEi: a, _ZN19LabelRecognizerWasm12DlrWasmClass25enableResultDeduplicationEb: a, _ZN19LabelRecognizerWasm12DlrWasmClass27getJvFromTextLineResultItemEPKN9dynamsoft3dlr19CTextLineResultItemEPKcb: a, _ZN19LabelRecognizerWasm12DlrWasmClass29enableResultCrossVerificationEb: a, _ZN19LabelRecognizerWasm12DlrWasmClassC1Ev: a, _ZN19LabelRecognizerWasm24getJvFromCharacterResultEPKN9dynamsoft3dlr16CCharacterResultE: a, _ZN19LabelRecognizerWasm26getJvBufferedCharacterItemEPKN9dynamsoft3dlr22CBufferedCharacterItemE: a, _ZN19LabelRecognizerWasm29getJvLocalizedTextLineElementEPKN9dynamsoft3dlr20intermediate_results25CLocalizedTextLineElementE: a, _ZN19LabelRecognizerWasm30getJvRecognizedTextLineElementEPKN9dynamsoft3dlr20intermediate_results26CRecognizedTextLineElementE: a, _ZN19LabelRecognizerWasm32getJvFromTextLineResultItem_JustEPKN9dynamsoft3dlr19CTextLineResultItemE: a, _ZN22DocumentNormalizerWasm10getVersionEv: a, _ZN22DocumentNormalizerWasm12DdnWasmClass15clearVerifyListEv: a, _ZN22DocumentNormalizerWasm12DdnWasmClass22getDuplicateForgetTimeEi: a, _ZN22DocumentNormalizerWasm12DdnWasmClass22setDuplicateForgetTimeEii: a, _ZN22DocumentNormalizerWasm12DdnWasmClass25enableResultDeduplicationEib: a, _ZN22DocumentNormalizerWasm12DdnWasmClass29enableResultCrossVerificationEib: a, _ZN22DocumentNormalizerWasm12DdnWasmClass31getJvFromDetectedQuadResultItemEPKN9dynamsoft3ddn23CDetectedQuadResultItemEPKcb: a, _ZN22DocumentNormalizerWasm12DdnWasmClass34getJvFromNormalizedImageResultItemEPKN9dynamsoft3ddn26CNormalizedImageResultItemEPKcb: a, _ZN22DocumentNormalizerWasm12DdnWasmClassC1Ev: a, _ZN22DocumentNormalizerWasm36getJvFromDetectedQuadResultItem_JustEPKN9dynamsoft3ddn23CDetectedQuadResultItemE: a, _ZN22DocumentNormalizerWasm39getJvFromNormalizedImageResultItem_JustEPKN9dynamsoft3ddn26CNormalizedImageResultItemE: a, _ZN9dynamsoft3dnn20CNeuralNetworkModule10GetVersionEv: a, _ZN9dynamsoft7utility14CUtilityModule10GetVersionEv: a, __assert_fail: ___assert_fail, __call_sighandler: ___call_sighandler, __cxa_throw: ___cxa_throw, __syscall__newselect: ___syscall__newselect, __syscall_chmod: ___syscall_chmod, __syscall_connect: ___syscall_connect, __syscall_fchmod: ___syscall_fchmod, __syscall_fcntl64: ___syscall_fcntl64, __syscall_fstat64: ___syscall_fstat64, __syscall_ftruncate64: ___syscall_ftruncate64, __syscall_getdents64: ___syscall_getdents64, __syscall_getuid32: ___syscall_getuid32, __syscall_ioctl: ___syscall_ioctl, __syscall_linkat: ___syscall_linkat, __syscall_lstat64: ___syscall_lstat64, __syscall_mkdirat: ___syscall_mkdirat, __syscall_newfstatat: ___syscall_newfstatat, __syscall_openat: ___syscall_openat, __syscall_readlinkat: ___syscall_readlinkat, __syscall_socket: ___syscall_socket, __syscall_stat64: ___syscall_stat64, __syscall_symlinkat: ___syscall_symlinkat, _abort_js: __abort_js, _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear, _gmtime_js: __gmtime_js, _localtime_js: __localtime_js, _setitimer_js: __setitimer_js, _tzset_js: __tzset_js, clock_time_get: _clock_time_get, emscripten_date_now: _emscripten_date_now, emscripten_log: _emscripten_log, emscripten_resize_heap: _emscripten_resize_heap, environ_get: _environ_get, environ_sizes_get: _environ_sizes_get, fd_close: _fd_close, fd_fdstat_get: _fd_fdstat_get, fd_read: _fd_read, fd_seek: _fd_seek, fd_write: _fd_write, proc_exit: _proc_exit }; createWasm(), Module.addFunction = addFunction; var stringToUTF8OnStack = e => { var r = lengthBytesUTF8(e) + 1, t = __emscripten_stack_alloc(r); return stringToUTF8(e, t, r), t }, loadDynamicLibrary = () => { }; function run() { runDependencies > 0 ? dependenciesFulfilled = run : (preRun(), runDependencies > 0 ? dependenciesFulfilled = run : (Module.calledRun = !0, ABORT || (initRuntime(), Module.UTF8ToString = UTF8ToString, wasmImports = wasmExports, _emscripten_bind_funcs(addFunction(((e, r, t) => stringToUTF8OnStack(self[UTF8ToString(e)][UTF8ToString(r)]()[UTF8ToString(t)]())), "iiii")), _emscripten_bind_funcs(addFunction(((e, r, t) => stringToUTF8OnStack((new (self[UTF8ToString(e)]))[UTF8ToString(r)](UTF8ToString(t)))), "iiii")), _emscripten_bind_funcs(addFunction(((e, r, t, n) => { self[UTF8ToString(e)](null, UTF8ToString(r).trim(), UTF8ToString(t), n) }), "viiii")), _emscripten_bind_funcs(addFunction(((e, r, t, n) => stringToUTF8OnStack(self[UTF8ToString(e)][UTF8ToString(r)][UTF8ToString(t)](UTF8ToString(n)) ? "" : self[UTF8ToString(e)][UTF8ToString(r)])), "iiiii")), Module.onRuntimeInitialized?.(), postRun()))) } run();